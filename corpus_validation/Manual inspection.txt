PROJECT:	Lean
SHA:	3426bd9ffd057e2393d927f818b9a0d721329659
DIFF:
commit 3426bd9ffd057e2393d927f818b9a0d721329659
Author: AlexCatarino <alexandre.catarino@gmail.com>
Date:   Tue Mar 22 11:38:41 2016 -0300

    Adds OrderTicketDemoAlgorithm.py
    
    Adds Python version of OrderTicketDemoAlgorithm

diff --git a/Algorithm.Python/OrderTicketDemoAlgorithm.py b/Algorithm.Python/OrderTicketDemoAlgorithm.py
new file mode 100644
index 00000000..b2554dc0
--- /dev/null
+++ b/Algorithm.Python/OrderTicketDemoAlgorithm.py
@@ -0,0 +1,353 @@
+﻿# QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
+# Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
+# 
+# Licensed under the Apache License, Version 2.0 (the "License"); 
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from datetime import datetime
+
+from clr import AddReference
+AddReference("System")
+AddReference("QuantConnect.Algorithm")
+AddReference("QuantConnect.Common")
+
+from System import *
+from QuantConnect import *
+from QuantConnect.Algorithm import *
+from QuantConnect.Orders import *
+from QuantConnect.Data import *
+
+
+class OrderTicketDemoAlgorithm(QCAlgorithm):
+    '''In this algorithm we submit/update/cancel each order type'''
+    def __init__(self):
+        self.__Symbol = Symbol.Create("SPY", SecurityType.Equity, "USA")
+        self.__openMarketOnOpenOrders = []
+        self.__openMarketOnCloseOrders = []
+        self.__openLimitOrders = []
+        self.__openStopMarketOrders = []
+        self.__openStopLimitOrders = []
+
+
+    def Initialize(self):
+        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''
+        
+        self.SetStartDate(2013,10,07)  #Set Start Date
+        self.SetEndDate(2013,10,11)    #Set End Date
+        self.SetCash(100000)           #Set Strategy Cash
+        # Find more symbols here: http://quantconnect.com/data
+        self.AddEquity(self.__Symbol.Value, Resolution.Minute)
+
+    def OnData(self, data):
+        '''OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.
+        
+        Arguments:
+            data: Slice object keyed by symbol containing the stock data
+        '''
+        # MARKET ORDERS
+        self.MarketOrders()
+
+        # LIMIT ORDERS
+        self.LimitOrders()
+
+        # STOP MARKET ORDERS
+        self.StopMarketOrders()
+
+        ## STOP LIMIT ORDERS
+        self.StopLimitOrders()
+
+        ## MARKET ON OPEN ORDERS
+        self.MarketOnOpenOrders()
+
+        ## MARKET ON CLOSE ORDERS
+        self.MarketOnCloseOrders()
+
+
+    def MarketOrders(self):
+        ''' MarketOrders are the only orders that are processed synchronously by default, so 
+        they'll fill by the next line of code. This behavior equally applies to live mode. 
+        You can opt out of this behavior by specifying the 'asynchronous' parameter as True.'''
+        if self.TimeIs(7, 9, 31):
+            self.Log("Submitting MarketOrder")
+
+            # submit a market order to buy 10 shares, this function returns an OrderTicket object
+            # we submit the order with asynchronous = False, so it block until it is filled
+            newTicket = self.MarketOrder(self.__Symbol, 10, asynchronous = False)
+            if newTicket.Status != OrderStatus.Filled:
+                self.Log("Synchronous market order was not filled synchronously!")
+                self.Quit()
+
+            # we can also submit the ticket asynchronously. In a backtest, we'll still perform the fill
+            # before the next time events for your algorithm. here we'll submit the order asynchronously 
+            # and try to cancel it, sometimes it will, sometimes it will be filled first.
+            newTicket = self.MarketOrder(self.__Symbol, 10, asynchronous = True)
+            response = newTicket.Cancel("Attempt to cancel async order")
+            if response.IsSuccess:
+                self.Log("Successfully canceled async market order: {0}".format(newTicket.OrderId))
+            else:
+                self.Log("Unable to cancel async market order: {0}".format(response.ErrorCode))
+
+
+    def LimitOrders(self):
+        '''LimitOrders are always processed asynchronously. Limit orders are used to
+        set 'good' entry points for an order. For example, you may wish to go
+        long a stock, but want a good price, so can place a LimitOrder to buy with
+        a limit price below the current market price. Likewise the opposite is True
+        when selling, you can place a LimitOrder to sell with a limit price above the
+        current market price to get a better sale price.
+        You can submit requests to update or cancel the LimitOrder at any time. 
+        The 'LimitPrice' for an order can be retrieved from the ticket using the 
+        OrderTicket.Get(OrderField) method, for example:
+        Code:
+            currentLimitPrice = orderTicket.Get(OrderField.LimitPrice)'''
+        if self.TimeIs(7, 12, 0):
+            self.Log("Submitting LimitOrder")
+
+            # submit a limit order to buy 10 shares at .1% below the bar's close
+            close = self.Securities[self.__Symbol.Value].Close
+            newTicket = self.LimitOrder(self.__Symbol, 10, close * .999)
+            self.__openLimitOrders.append(newTicket)
+
+            # submit another limit order to sell 10 shares at .1% above the bar's close
+            newTicket = self.LimitOrder(self.__Symbol, 10, close * 1.001)
+            self.__openLimitOrders.append(newTicket)
+
+        # when we submitted new limit orders we placed them into this list,
+        # so while there's two entries they're still open and need processing
+        if len(self.__openLimitOrders) == 2:
+            openOrders = self.__openLimitOrders
+
+            # check if either is filled and cancel the other
+            longOrder = openOrders[0]
+            shortOrder = openOrders[1]
+            if self.CheckPairOrdersForFills(longOrder, shortOrder):
+                self.__openLimitOrders = []
+                return
+
+            # if niether order has filled, bring in the limits by a penny
+            newLongLimit = longOrder.Get(OrderField.LimitPrice) + 0.01
+            newShortLimit = shortOrder.Get(OrderField.LimitPrice) - 0.01
+            self.Log("Updating limits - Long: {0:.2f} Short: {1:.2f}".format(newLongLimit, newShortLimit))
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.LimitPrice = newLongLimit
+            updateOrderFields.Tag = "Update #{0}".format(len(longOrder.UpdateRequests) + 1)
+            longOrder.Update(updateOrderFields)
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.LimitPrice = newShortLimit
+            updateOrderFields.Tag = "Update #{0}".format(len(shortOrder.UpdateRequests) + 1)
+            shortOrder.Update(updateOrderFields)
+
+
+    def StopMarketOrders(self):
+        '''StopMarketOrders work in the opposite way that limit orders do.
+        When placing a long trade, the stop price must be above current
+        market price. In this way it's a 'stop loss' for a short trade.
+        When placing a short trade, the stop price must be below current
+        market price. In this way it's a 'stop loss' for a long trade.
+        You can submit requests to update or cancel the StopMarketOrder at any time. 
+        The 'StopPrice' for an order can be retrieved from the ticket using the 
+        OrderTicket.Get(OrderField) method, for example:
+        Code:
+            currentStopPrice = orderTicket.Get(OrderField.StopPrice)'''
+        if self.TimeIs(7, 12 + 4, 0):
+            self.Log("Submitting StopMarketOrder")
+
+            # a long stop is triggered when the price rises above the value
+            # so we'll set a long stop .25% above the current bar's close
+            close = self.Securities[self.__Symbol.Value].Close
+            newTicket = self.StopMarketOrder(self.__Symbol, 10, close * 1.0025)
+            self.__openStopMarketOrders.append(newTicket)
+
+            # a short stop is triggered when the price falls below the value
+            # so we'll set a short stop .25% below the current bar's close
+            newTicket = self.StopMarketOrder(self.__Symbol, -10, close * .9975)
+            self.__openStopMarketOrders.append(newTicket)
+
+        # when we submitted new stop market orders we placed them into this list,
+        # so while there's two entries they're still open and need processing
+        if len(self.__openStopMarketOrders) == 2:
+            # check if either is filled and cancel the other
+            longOrder = self.__openStopMarketOrders[0]
+            shortOrder = self.__openStopMarketOrders[1]
+            if self.CheckPairOrdersForFills(longOrder, shortOrder):
+                self.__openStopMarketOrders = []
+                return
+
+            # if neither order has filled, bring in the stops by a penny
+            newLongStop = longOrder.Get(OrderField.StopPrice) - 0.01
+            newShortStop = shortOrder.Get(OrderField.StopPrice) + 0.01
+            self.Log("Updating stops - Long: {0:.2f} Short: {1:.2f}".format(newLongStop, newShortStop))
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.StopPrice = newLongStop
+            updateOrderFields.Tag = "Update #{0}".format(len(longOrder.UpdateRequests) + 1)
+            longOrder.Update(updateOrderFields)
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.StopPrice = newShortStop
+            updateOrderFields.Tag = "Update #{0}".format(len(shortOrder.UpdateRequests) + 1)
+            shortOrder.Update(updateOrderFields)
+            self.Log("Updated price - Long: {0} Short: {1}".format(longOrder.Get(OrderField.StopPrice), shortOrder.Get(OrderField.StopPrice)))
+            
+
+    def StopLimitOrders(self):
+        '''StopLimitOrders work as a combined stop and limit order. First, the
+        price must pass the stop price in the same way a StopMarketOrder works,
+        but then we're also gauranteed a fill price at least as good as the
+        limit price. This order type can be beneficial in gap down scenarios
+        where a StopMarketOrder would have triggered and given the not as beneficial
+        gapped down price, whereas the StopLimitOrder could protect you from
+        getting the gapped down price through prudent placement of the limit price.
+        You can submit requests to update or cancel the StopLimitOrder at any time.
+        The 'StopPrice' or 'LimitPrice' for an order can be retrieved from the ticket
+        using the OrderTicket.Get(OrderField) method, for example:
+        Code:
+            currentStopPrice = orderTicket.Get(OrderField.StopPrice)
+            currentLimitPrice = orderTicket.Get(OrderField.LimitPrice)'''
+        if self.TimeIs(8, 12, 1):
+            self.Log("Submitting StopLimitOrder")
+
+            # a long stop is triggered when the price rises above the
+            # value so we'll set a long stop .25% above the current bar's
+            # close now we'll also be setting a limit, this means we are
+            # gauranteed to get at least the limit price for our fills,
+            # so make the limit price a little softer than the stop price
+
+            close = self.Securities[self.__Symbol.Value].Close
+            newTicket = self.StopLimitOrder(self.__Symbol, 10, close * 1.001, close - 0.03)
+            self.__openStopLimitOrders.append(newTicket)
+
+            # a short stop is triggered when the price falls below the
+            # value so we'll set a short stop .25% below the current bar's
+            # close now we'll also be setting a limit, this means we are
+            # gauranteed to get at least the limit price for our fills,
+            # so make the limit price a little softer than the stop price
+
+            newTicket = self.StopLimitOrder(self.__Symbol, -10, close * .999, close + 0.03)
+            self.__openStopLimitOrders.append(newTicket)
+
+        # when we submitted new stop limit orders we placed them into this list,
+        # so while there's two entries they're still open and need processing
+        if len(self.__openStopLimitOrders) == 2:
+            longOrder = self.__openStopLimitOrders[0]
+            shortOrder = self.__openStopLimitOrders[1]
+            if self.CheckPairOrdersForFills(longOrder, shortOrder):
+                self.__openStopLimitOrders = []
+                return
+
+            # if neither order has filled, bring in the stops/limits in by a penny
+
+            newLongStop = longOrder.Get(OrderField.StopPrice) - 0.01
+            newLongLimit = longOrder.Get(OrderField.LimitPrice) + 0.01
+            newShortStop = shortOrder.Get(OrderField.StopPrice) + 0.01
+            newShortLimit = shortOrder.Get(OrderField.LimitPrice) - 0.01
+            self.Log("Updating stops  - Long: {0:.2f} Short: {1:.2f}".format(newLongStop, newShortStop))
+            self.Log("Updating limits - Long: {0:.2f}  Short: {1:.2f}".format(newLongLimit, newShortLimit))
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.StopPrice = newLongStop
+            updateOrderFields.LimitPrice = newLongLimit
+            updateOrderFields.Tag = "Update #{0}".format(len(longOrder.UpdateRequests) + 1)
+            longOrder.Update(updateOrderFields)
+
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.StopPrice = newShortStop
+            updateOrderFields.LimitPrice = newShortLimit
+            updateOrderFields.Tag = "Update #{0}".format(len(shortOrder.UpdateRequests) + 1)
+            shortOrder.Update(updateOrderFields)
+
+
+    def MarketOnCloseOrders(self):
+        '''MarketOnCloseOrders are always executed at the next market's closing price.
+        The only properties that can be updated are the quantity and order tag properties.'''
+        if self.TimeIs(9, 12, 0):
+            self.Log("Submitting MarketOnCloseOrder")
+
+            # open a new position or triple our existing position
+            qty = self.Portfolio[self.__Symbol.Value].Quantity
+            qty = 100 if qty == 0 else 2*qty
+
+            newTicket = self.MarketOnCloseOrder(self.__Symbol, qty);
+            self.__openMarketOnCloseOrders.append(newTicket)
+
+        if len(self.__openMarketOnCloseOrders) == 1 and datetime(self.Time).minute == 59:
+            ticket = self.__openMarketOnCloseOrders[0]
+            # check for fills
+            if ticket.Status == OrderStatus.Filled:
+                self.__openMarketOnCloseOrders = []
+                return
+
+            quantity = ticket.Quantity + 1
+            self.Log("Updating quantity  - New Quantity: {0}".format(quantity))
+
+            # we can update the quantity and tag
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.Quantity = quantity
+            updateOrderFields.Tag = "Update #{0}".format(len(ticket.UpdateRequests) + 1)
+            ticket.Update(updateOrderFields)
+
+        if self.TimeIs(self.EndDate.Day, 12 + 3, 45):
+            self.Log("Submitting MarketOnCloseOrder to liquidate end of algorithm")
+            self.MarketOnCloseOrder(self.__Symbol, -self.Portfolio[self.__Symbol.Value].Quantity, "Liquidate end of algorithm")
+
+
+    def MarketOnOpenOrders(self):
+        '''MarketOnOpenOrders are always executed at the next
+        market's opening price. The only properties that can
+        be updated are the quantity and order tag properties.'''
+        if self.TimeIs(8, 12 + 2, 0):
+            self.Log("Submitting MarketOnOpenOrder")
+
+            # its EOD, let's submit a market on open order to short even more!
+            newTicket = self.MarketOnOpenOrder(self.__Symbol, 50)
+            self.__openMarketOnOpenOrders.append(newTicket)
+
+        if len(self.__openMarketOnOpenOrders) == 1 and datetime(self.Time).minute == 59:
+            ticket = self.__openMarketOnOpenOrders[0]
+
+            # check for fills
+            if ticket.Status == OrderStatus.Filled:
+                self.__openMarketOnOpenOrders = []
+                return
+
+            quantity = ticket.Quantity + 1
+            self.Log("Updating quantity  - New Quantity: {0}".format(quantity))
+
+            # we can update the quantity and tag
+            updateOrderFields = UpdateOrderFields()
+            updateOrderFields.Quantity = quantity
+            updateOrderFields.Tag = "Update #{0}".format(len(ticket.UpdateRequests) + 1)
+            ticket.Update(updateOrderFields)
+
+
+    def OnOrderEvent(self, orderEvent):
+        order = self.Transactions.GetOrderById(orderEvent.OrderId)
+        self.Log("{0}: {1}: {2}".format(self.Time, order.Type, orderEvent))
+
+
+    def CheckPairOrdersForFills(self, longOrder, shortOrder):
+        if longOrder.Status == OrderStatus.Filled:
+            self.Log("{0}: Cancelling short order, long order is filled.".format(shortOrder.OrderType))
+            shortOrder.Cancel("Long filled.")
+            return True
+        
+        if shortOrder.Status == OrderStatus.Filled:
+            self.Log("{0}: Cancelling long order, short order is filled.".format(longOrder.OrderType))
+            longOrder.Cancel("Short filled")
+            return True
+
+        return False;
+
+
+    def TimeIs(self, day, hour, minute):
+        pyTime = datetime(self.Time)
+        return pyTime.day == day and pyTime.hour == hour and pyTime.minute == minute
\ No newline at end of file
diff --git a/Algorithm.Python/QuantConnect.Algorithm.Python.csproj b/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
index bf406d2f..784d16c5 100644
--- a/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
+++ b/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
@@ -104,6 +104,7 @@
   </ItemGroup>
   <ItemGroup>
     <Content Include="AddRemoveSecurityRegressionAlgorithm.py" />
+    <Content Include="OrderTicketDemoAlgorithm.py" />
     <Content Include="BasicTemplateFillForwardAlgorithm.py" />
     <Content Include="DailyAlgorithm.py" />
     <Content Include="MarketOnOpenOnCloseAlgorithm.py" />

ATOMIC:	YES


PROJECT:	Lean
SHA:	3673373ad948f7d71fa844705bacd09bf9133a16
DIFF:
commit 3673373ad948f7d71fa844705bacd09bf9133a16
Author: AlexCatarino <alexandre.catarino@gmail.com>
Date:   Sat Feb 13 14:33:05 2016 -0200

    Add AddRemoveSecurityRegressionAlgorithm.py
    
    Add Python version of AddRemoveSecurityRegressionAlgorithm

diff --git a/Algorithm.Python/AddRemoveSecurityRegressionAlgorithm.py b/Algorithm.Python/AddRemoveSecurityRegressionAlgorithm.py
new file mode 100644
index 00000000..eca0c217
--- /dev/null
+++ b/Algorithm.Python/AddRemoveSecurityRegressionAlgorithm.py
@@ -0,0 +1,73 @@
+﻿# QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
+# Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
+# 
+# Licensed under the Apache License, Version 2.0 (the "License"); 
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import clr
+clr.AddReference("System")
+clr.AddReference("QuantConnect.Common")
+clr.AddReference("QuantConnect.Algorithm")
+
+from System import *
+from QuantConnect import *
+from QuantConnect.Algorithm import *
+from QuantConnect.Data.Market import *
+import QuantConnect.Orders as Orders
+clr.ImportExtensions(Orders.OrderExtensions)
+
+class AddRemoveSecurityRegressionAlgorithm(QCAlgorithm):
+    '''Basic template algorithm simply initializes the date range and cash'''
+
+    def __init__(self):    
+        self._lastAction = None
+
+    def Initialize(self):
+        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''
+        
+        self.SetStartDate(2013,10,07)  #Set Start Date
+        self.SetEndDate(2013,10,11)    #Set End Date
+        self.SetCash(100000)           #Set Strategy Cash
+        # Find more symbols here: http://quantconnect.com/data
+        self.AddSecurity(SecurityType.Equity, "SPY")
+
+    def OnData(self, data):
+        '''OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.
+        
+        Arguments:
+            data: Slice object keyed by symbol containing the stock data
+        '''
+        if self._lastAction is not None and self._lastAction.Date == self.Time.Date:
+            return
+
+        if not self.Portfolio.Invested:
+            self.SetHoldings("SPY", .5)
+            self._lastAction = self.Time
+
+        if self.Time.DayOfWeek == DayOfWeek.Tuesday:
+            self.AddSecurity(SecurityType.Equity, "AIG")
+            self.AddSecurity(SecurityType.Equity, "BAC")
+            self._lastAction = self.Time
+
+        if self.Time.DayOfWeek == DayOfWeek.Wednesday:
+            self.SetHoldings("AIG", .25)
+            self.SetHoldings("BAC", .25)
+            self._lastAction = self.Time
+
+        if self.Time.DayOfWeek == DayOfWeek.Thursday:
+            self.RemoveSecurity("AIG")
+            self.RemoveSecurity("BAC")
+            self._lastAction = self.Time
+
+    def OnOrderEvent(self, orderEvent):
+        if orderEvent.Status == Orders.OrderStatus.Submitted:
+            print "{0}: Submitted: {1}".format(self.Time, self.Transactions.GetOrderById(orderEvent.OrderId))
+        if orderEvent.Status.IsFill():
+            print "{0}: Filled: {1}".format(self.Time, self.Transactions.GetOrderById(orderEvent.OrderId))
\ No newline at end of file
diff --git a/Algorithm.Python/QuantConnect.Algorithm.Python.csproj b/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
index 153f80ad..a2d21c67 100644
--- a/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
+++ b/Algorithm.Python/QuantConnect.Algorithm.Python.csproj
@@ -103,6 +103,7 @@
     <None Include="readme.md" />
   </ItemGroup>
   <ItemGroup>
+    <Content Include="AddRemoveSecurityRegressionAlgorithm.py" />
     <Content Include="BasicTemplateAlgorithm.py" />
     <Content Include="Lib\abc.py" />
     <Content Include="Lib\aifc.py" />

ATOMIC:	YES


PROJECT:	Nancy
SHA:	ca0260375ae1e3815758c81d283956411bf2d66b
DIFF:
commit ca0260375ae1e3815758c81d283956411bf2d66b
Author: Andreas Hakansson <andreas@selfinflicted.org>
Date:   Sun Aug 5 15:23:11 2012 +0200

    Fixed broken invoker tests

diff --git a/src/Nancy.Tests/Unit/Routing/DefaultRouteInvokerFixture.cs b/src/Nancy.Tests/Unit/Routing/DefaultRouteInvokerFixture.cs
index 835d2bcb..74a2c615 100644
--- a/src/Nancy.Tests/Unit/Routing/DefaultRouteInvokerFixture.cs
+++ b/src/Nancy.Tests/Unit/Routing/DefaultRouteInvokerFixture.cs
@@ -3,6 +3,7 @@
     using System;
     using System.IO;
     using System.Linq;
+    using FakeItEasy;
     using Fakes;
     using Nancy.Bootstrapper;
     using Nancy.Diagnostics;
@@ -24,7 +25,7 @@
         {
             // Given
             var parameters = new DynamicDictionary();
-            var route = new FakeRoute();
+            var route = new FakeRoute(10);
             var context = new NancyContext();
 
             // When
diff --git a/src/Nancy/Routing/DefaultRouteInvoker.cs b/src/Nancy/Routing/DefaultRouteInvoker.cs
index d8f94ffb..fb927f79 100644
--- a/src/Nancy/Routing/DefaultRouteInvoker.cs
+++ b/src/Nancy/Routing/DefaultRouteInvoker.cs
@@ -46,16 +46,22 @@ namespace Nancy.Routing
                 result = new Response();
             }
 
-            var strategy = this.GetInvocationStrategy(result.GetType());
+            return this.InvokeRouteWithStrategy(result, context);
+        }
+
+        private Response InvokeRouteWithStrategy(dynamic result, NancyContext context)
+        {
+            var isResponse =
+                (CastResultToResponse(result) == null);
 
-            return strategy.Invoke(result, context);
+            return (isResponse)
+                ? ProcessAsRealResponse(result, context)
+                : this.ProcessAsNegotiator(result, context);
         }
 
-        private Func<dynamic, NancyContext, Response> GetInvocationStrategy(Type resultType)
+        private static Response CastResultToResponse(dynamic result)
         {
-            return invocationStrategies.Where(invocationStrategy => invocationStrategy.Key.IsAssignableFrom(resultType))
-                                        .Select(invocationStrategy => invocationStrategy.Value)
-                                        .First();
+            return result as Response;
         }
 
         private IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>> GetCompatibleProcessorsByHeader(string acceptHeader, dynamic model, NancyContext context)
@@ -78,7 +84,7 @@ namespace Nancy.Routing
             return (Response)routeResult;
         }
 
-        private Response NegotiateResponse(IEnumerable<Tuple<string, IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>>>> compatibleHeaders, object model, Negotiator negotiator, NancyContext context)
+        private static Response NegotiateResponse(IEnumerable<Tuple<string, IEnumerable<Tuple<IResponseProcessor, ProcessorMatch>>>> compatibleHeaders, object model, Negotiator negotiator, NancyContext context)
         {
             foreach (var compatibleHeader in compatibleHeaders)
             {

ATOMIC:	YES


PROJECT:	Lean
SHA:	fc6848a0294214f890d31120ad311bc0e2184c6e
DIFF:
commit fc6848a0294214f890d31120ad311bc0e2184c6e
Author: Stefano Raggi <stefano.raggi67@alice.it>
Date:   Wed Feb 10 00:01:54 2016 +0100

    Adds missing QCAlgorithm indicator methods
    
    Closes #283

diff --git a/Algorithm/QCAlgorithm.Indicators.cs b/Algorithm/QCAlgorithm.Indicators.cs
index 41abf607..8d8300de 100644
--- a/Algorithm/QCAlgorithm.Indicators.cs
+++ b/Algorithm/QCAlgorithm.Indicators.cs
@@ -14,14 +14,11 @@
 */
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using QuantConnect.Data;
 using QuantConnect.Data.Consolidators;
 using QuantConnect.Data.Market;
 using QuantConnect.Indicators;
-using QuantConnect.Securities;
-using QuantConnect.Util;
 
 namespace QuantConnect.Algorithm
 {
@@ -79,7 +76,7 @@ namespace QuantConnect.Algorithm
         /// Creates a new IchimokuKinkoHyo indicator for the symbol. The indicator will be automatically
         /// updated on the given resolution.
         /// </summary>
-        /// <param name="symbol">The symbol whose ATR we want</param>
+        /// <param name="symbol">The symbol whose ICHIMOKU we want</param>
         /// <param name="tenkanPeriod">The period to calculate the Tenkan-sen period</param>
         /// <param name="kijunPeriod">The period to calculate the Kijun-sen period</param>
         /// <param name="senkouAPeriod">The period to calculate the Tenkan-sen period</param>
@@ -380,11 +377,11 @@ namespace QuantConnect.Algorithm
         /// Creates a new RateOfChange indicator. This will compute the n-period rate of change in the security.
         /// The indicator will be automatically updated on the given resolution.
         /// </summary>
-        /// <param name="symbol">The symbol whose rateofchange we want</param>
-        /// <param name="period">The period over which to compute the rateofchange</param>
+        /// <param name="symbol">The symbol whose RateOfChange we want</param>
+        /// <param name="period">The period over which to compute the RateOfChange</param>
         /// <param name="resolution">The resolution</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
-        /// <returns>The rateofchange indicator for the requested symbol over the specified period</returns>
+        /// <returns>The RateOfChange indicator for the requested symbol over the specified period</returns>
         public RateOfChange ROC(Symbol symbol, int period, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
         {
             string name = CreateIndicatorName(symbol, "ROC" + period, resolution);
@@ -397,11 +394,11 @@ namespace QuantConnect.Algorithm
         /// Creates a new RateOfChangePercent indicator. This will compute the n-period percentage rate of change in the security.
         /// The indicator will be automatically updated on the given resolution.
         /// </summary>
-        /// <param name="symbol">The symbol whose rateofchange we want</param>
-        /// <param name="period">The period over which to compute the rateofchangepercent</param>
+        /// <param name="symbol">The symbol whose RateOfChangePercent we want</param>
+        /// <param name="period">The period over which to compute the RateOfChangePercent</param>
         /// <param name="resolution">The resolution</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
-        /// <returns>The rateofchangepercent indicator for the requested symbol over the specified period</returns>
+        /// <returns>The RateOfChangePercent indicator for the requested symbol over the specified period</returns>
         public RateOfChangePercent ROCP(Symbol symbol, int period, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
         {
             string name = CreateIndicatorName(symbol, "ROCP" + period, resolution);
@@ -432,8 +429,8 @@ namespace QuantConnect.Algorithm
         /// Creates a new LinearWeightedMovingAverage indicator.  This indicator will linearly distribute
         /// the weights across the periods.  
         /// </summary>
-        /// <param name="symbol">The symbol whose Williams %R we want</param>
-        /// <param name="period">The period over which to compute the Williams %R</param>
+        /// <param name="symbol">The symbol whose LWMA we want</param>
+        /// <param name="period">The period over which to compute the LWMA</param>
         /// <param name="resolution">The resolution</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
         /// <returns></returns>
@@ -581,7 +578,7 @@ namespace QuantConnect.Algorithm
         /// <param name="period">The LSMA period. Normally 14.</param>
         /// <param name="resolution">The resolution.</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to casting the input value to a TradeBar.</param>
-        /// <returns>An LeastSquaredMovingAverage configured with the specified period</returns>
+        /// <returns>A LeastSquaredMovingAverage configured with the specified period</returns>
         public LeastSquaresMovingAverage LSMA(Symbol symbol, int period, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
         {
             var name = CreateIndicatorName(symbol, "LSMA" + period, resolution);
@@ -599,7 +596,7 @@ namespace QuantConnect.Algorithm
         /// <param name="afMax">Acceleration factor max value. Normally 0.2</param>
         /// <param name="resolution">The resolution</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to casting the input value to a TradeBar</param>
-        /// <returns>An AroonOscillator configured with the specified periods</returns>
+        /// <returns>A ParabolicStopAndReverse configured with the specified periods</returns>
         public ParabolicStopAndReverse PSAR(Symbol symbol, decimal afStart = 0.02m, decimal afIncrement = 0.02m, decimal afMax = 0.2m, Resolution? resolution = null, Func<BaseData, TradeBar> selector = null)
         {
             var name = CreateIndicatorName(symbol, string.Format("PSAR({0},{1},{2})", afStart, afIncrement, afMax), resolution);
@@ -691,7 +688,7 @@ namespace QuantConnect.Algorithm
         /// Creates a new ChandeMomentumOscillator indicator.
         /// </summary>
         /// <param name="symbol">The symbol whose CMO we want</param>
-        /// <param name="period">The period over which to compute the VAR</param>
+        /// <param name="period">The period over which to compute the CMO</param>
         /// <param name="resolution">The resolution</param>
         /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
         /// <returns>The ChandeMomentumOscillator indicator for the requested symbol over the specified period</returns>
@@ -767,6 +764,55 @@ namespace QuantConnect.Algorithm
             return rocr;
         }
 
+        /// <summary>
+        /// Creates a new MeanAbsoluteDeviation indicator.
+        /// </summary>
+        /// <param name="symbol">The symbol whose MeanAbsoluteDeviation we want</param>
+        /// <param name="period">The period over which to compute the MeanAbsoluteDeviation</param>
+        /// <param name="resolution">The resolution</param>
+        /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
+        /// <returns>The MeanAbsoluteDeviation indicator for the requested symbol over the specified period</returns>
+        public MeanAbsoluteDeviation MAD(Symbol symbol, int period, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
+        {
+            var name = CreateIndicatorName(symbol, "MAD" + period, resolution);
+            var mad = new MeanAbsoluteDeviation(name, period);
+            RegisterIndicator(symbol, mad, resolution, selector);
+            return mad;
+        }
+
+        /// <summary>
+        /// Creates a new Momersion indicator.
+        /// </summary>
+        /// <param name="symbol">The symbol whose Momersion we want</param>
+        /// <param name="minPeriod">The minimum period over which to compute the Momersion</param>
+        /// <param name="fullPeriod">The full period over which to compute the Momersion</param>
+        /// <param name="resolution">The resolution</param>
+        /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
+        /// <returns>The Momersion indicator for the requested symbol over the specified period</returns>
+        public MomersionIndicator MOMERSION(Symbol symbol, int minPeriod, int fullPeriod, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
+        {
+            var name = CreateIndicatorName(symbol, string.Format("MOMERSION({0},{1})", minPeriod, fullPeriod), resolution);
+            var momersion = new MomersionIndicator(name, minPeriod, fullPeriod);
+            RegisterIndicator(symbol, momersion, resolution, selector);
+            return momersion;
+        }
+
+        /// <summary>
+        /// Creates a new Sum indicator.
+        /// </summary>
+        /// <param name="symbol">The symbol whose Sum we want</param>
+        /// <param name="period">The period over which to compute the Sum</param>
+        /// <param name="resolution">The resolution</param>
+        /// <param name="selector">Selects a value from the BaseData to send into the indicator, if null defaults to the Value property of BaseData (x => x.Value)</param>
+        /// <returns>The Sum indicator for the requested symbol over the specified period</returns>
+        public Sum SUM(Symbol symbol, int period, Resolution? resolution = null, Func<BaseData, decimal> selector = null)
+        {
+            var name = CreateIndicatorName(symbol, "SUM" + period, resolution);
+            var sum = new Sum(name, period);
+            RegisterIndicator(symbol, sum, resolution, selector);
+            return sum;
+        }
+
         /// <summary>
         /// Creates and registers a new consolidator to receive automatic updates at the specified resolution as well as configures
         /// the indicator to receive updates from the consolidator.

ATOMIC:	NO, contains refactorings. Tangle not visible in PDG.


PROJECT:	RestSharp
SHA:	af1e38cfb1e28a3fe9daa4dc4caa6bd736001597
DIFF:
commit af1e38cfb1e28a3fe9daa4dc4caa6bd736001597
Author: Alexey Zimarev <alex@zimarev.com>
Date:   Sun Oct 22 19:48:58 2017 +0200

    Build branches differently

diff --git a/appveyor.yml b/appveyor.yml
index 70f898b..a601f75 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -1,11 +1,30 @@
 version: 105.0.1.{build}
 image: Visual Studio 2017
-branches:
-  only:
-  - master
-  - develop
+
 build_script:
   - build.bat
+
 skip_tags: true
-artifacts:
-  path: 'RestSharp\bin\Release\*.nupkg'
\ No newline at end of file
+
+-
+  branches:
+    only:
+      - master
+
+  artifacts:
+    path: 'RestSharp\bin\Release\*.nupkg'
+
+  configuration: Release
+
+-
+  branches:
+    only:
+      - develop
+
+  artifacts:
+    path: 'RestSharp\bin\Debug\*.nupkg'
+
+  configuration: Debug
+
+-
+  configuration: Debug
\ No newline at end of file

ATOMIC:	YES


PROJECT:	Commandline
SHA:	c2849fa9b39dca8d0460158d7089c6664f3f1ac6
DIFF:
commit c2849fa9b39dca8d0460158d7089c6664f3f1ac6
Author: gsscoder <gsscoder@gmail.com>
Date:   Sun Apr 28 16:02:09 2013 +0200

    Double dash syntax support added to kernel.

diff --git a/src/CommandLine.Tests/Unit/Core/InstanceBuilderTests.cs b/src/CommandLine.Tests/Unit/Core/InstanceBuilderTests.cs
index 0205dc8..ffc3cc8 100644
--- a/src/CommandLine.Tests/Unit/Core/InstanceBuilderTests.cs
+++ b/src/CommandLine.Tests/Unit/Core/InstanceBuilderTests.cs
@@ -193,11 +193,15 @@ namespace CommandLine.Tests.Unit.Core
                     StringSequence = new[] { "-a", "--bee", "-c" },
                     IntValue = 20
                 };
+            var arguments = new[] { "--stringvalue", "str1", "--", "10", "-a", "--bee", "-c", "20" };
 
             // Exercize system 
             var result = InstanceBuilder.Build(
                 () => new FakeOptionsWithValues(),
-                new[] { "--stringvalue", "str1", "10", "-a", "--bee", "-c", "20" },
+                optionSpecs =>
+                    Tokenizer.PreprocessDashDash(arguments,
+                        args => Tokenizer.Tokenize(args, name => NameLookup.Contains(name, optionSpecs, StringComparer.Ordinal))),
+                arguments,
                 StringComparer.Ordinal,
                 CultureInfo.InvariantCulture);
 
diff --git a/src/CommandLine/Core/InstanceBuilder.cs b/src/CommandLine/Core/InstanceBuilder.cs
index 3be1617..7d3eaee 100644
--- a/src/CommandLine/Core/InstanceBuilder.cs
+++ b/src/CommandLine/Core/InstanceBuilder.cs
@@ -15,6 +15,22 @@ namespace CommandLine.Core
             IEnumerable<string> arguments,
             StringComparer nameComparer,
             CultureInfo parsingCulture)
+        {
+            return InstanceBuilder.Build(
+                factory,
+                optionSpecs =>
+                    Tokenizer.Tokenize(arguments, name => NameLookup.Contains(name, optionSpecs, nameComparer)),
+                arguments,
+                nameComparer,
+                parsingCulture);
+        }
+
+        public static ParserResult<T> Build<T>(
+            Func<T> factory,
+            Func<IEnumerable<OptionSpecification>, StatePair<IEnumerable<Token>>> tokenizer,
+            IEnumerable<string> arguments,
+            StringComparer nameComparer,
+            CultureInfo parsingCulture)
         {
             var instance = factory();
 
@@ -33,9 +49,7 @@ namespace CommandLine.Core
                 .ThrowingValidate(SpecificationGuards.Lookup)
                 .OfType<OptionSpecification>();
 
-            var tokenizerResult = Tokenizer.Tokenize(
-                arguments,
-                name => NameLookup.Contains(name, optionSpecs, nameComparer));
+            var tokenizerResult = tokenizer(optionSpecs);
 
             var tokens = tokenizerResult.Value;
 
@@ -55,8 +69,8 @@ namespace CommandLine.Core
                 (vals, type, isScalar) => TypeConverter.ChangeType(vals, type, isScalar, parsingCulture));
 
             var missingValueErrors = from token in partitions.Item3
-                select new MissingValueOptionError(
-                    NameInfo.FromOptionSpecification(optionSpecs.Single(o => token.Text.MatchName(o.ShortName, o.LongName, nameComparer))));
+                                     select new MissingValueOptionError(
+                                         NameInfo.FromOptionSpecification(optionSpecs.Single(o => token.Text.MatchName(o.ShortName, o.LongName, nameComparer))));
 
             var specPropsWithValue = optionSpecProps.Value.Concat(valueSpecProps.Value);
 
diff --git a/src/CommandLine/Core/StatePair.cs b/src/CommandLine/Core/StatePair.cs
index 1399fde..9d9f48b 100644
--- a/src/CommandLine/Core/StatePair.cs
+++ b/src/CommandLine/Core/StatePair.cs
@@ -59,12 +59,19 @@ namespace CommandLine.Core
 
     internal static class StatePair
     {
-        public static StatePair<T> Create<T>(T instance, IEnumerable<Error> errors)
+        public static StatePair<T> Create<T>(T value, IEnumerable<Error> errors)
         {
-            if (object.Equals(instance, default(T))) throw new ArgumentNullException("instance");
+            if (object.Equals(value, default(T))) throw new ArgumentNullException("value");
             if (errors == null) throw new ArgumentNullException("errors");
 
-            return new StatePair<T>(instance, errors);
+            return new StatePair<T>(value, errors);
+        }
+
+        public static StatePair<T2> MapValue<T1, T2>(
+            this StatePair<T1> statePair,
+            Func<T1, T2> func)
+        {
+            return new StatePair<T2>(func(statePair.Value), statePair.Errors);
         }
     }
 }
diff --git a/src/CommandLine/Core/Tokenizer.cs b/src/CommandLine/Core/Tokenizer.cs
index d997dae..0e70d03 100644
--- a/src/CommandLine/Core/Tokenizer.cs
+++ b/src/CommandLine/Core/Tokenizer.cs
@@ -3,12 +3,15 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using CommandLine.Infrastructure;
 
 namespace CommandLine.Core
 {
     internal static class Tokenizer
     {
-        public static StatePair<IEnumerable<Token>> Tokenize(IEnumerable<string> arguments, Func<string, bool> nameLookup)
+        public static StatePair<IEnumerable<Token>> Tokenize(
+            IEnumerable<string> arguments,
+            Func<string, bool> nameLookup)
         {
             if (arguments == null) throw new ArgumentNullException("arguments");
 
@@ -28,6 +31,21 @@ namespace CommandLine.Core
             return StatePair.Create(tokens.Except(unkTokens), errors.Concat(from t in unkTokens select new UnknownOptionError(t.Text)));
         }
 
+        public static StatePair<IEnumerable<Token>> PreprocessDashDash(
+            IEnumerable<string> arguments,
+            Func<IEnumerable<string>, StatePair<IEnumerable<Token>>> tokenizer)
+        {
+            if (arguments == null) throw new ArgumentNullException("arguments");
+
+            if (arguments.Any(arg => arg.EqualsOrdinal("--")))
+            {
+                var tokenizerResult = tokenizer(arguments.TakeWhile(arg => !arg.EqualsOrdinal("--")));
+                var values = arguments.SkipWhile(arg => !arg.EqualsOrdinal("--")).Skip(1).Select(t => Token.Value(t));
+                return tokenizerResult.MapValue(tokens => tokens.Concat(values));
+            }
+            return tokenizer(arguments);
+        }
+
         private static IEnumerable<Token> TokenizeShortName(
             string value,
             Func<string, bool> nameLookup)
diff --git a/src/CommandLine/Infrastructure/StringExtensions.cs b/src/CommandLine/Infrastructure/StringExtensions.cs
index 7682ea6..fc1985f 100644
--- a/src/CommandLine/Infrastructure/StringExtensions.cs
+++ b/src/CommandLine/Infrastructure/StringExtensions.cs
@@ -31,5 +31,10 @@ namespace CommandLine.Infrastructure
         {
             return new string(' ', value);
         }
+
+        public static bool EqualsOrdinal(this string strA, string strB)
+        {
+            return string.CompareOrdinal(strA, strB) == 0;
+        }
     }
 }
\ No newline at end of file

ATOMIC:	YES


PROJECT:	Lean
SHA:	d8e062cd5c1fffffe08e605720b50aa9c1051bac
DIFF:
commit d8e062cd5c1fffffe08e605720b50aa9c1051bac
Author: Stefano Raggi <stefano.raggi67@alice.it>
Date:   Wed Oct 4 18:53:20 2017 +0200

    Add account to ExecutionDetailsEventArgs.ToString for logging

diff --git a/Brokerages/InteractiveBrokers/Client/ExecutionDetailsEventArgs.cs b/Brokerages/InteractiveBrokers/Client/ExecutionDetailsEventArgs.cs
index eac5af58..d3e26535 100644
--- a/Brokerages/InteractiveBrokers/Client/ExecutionDetailsEventArgs.cs
+++ b/Brokerages/InteractiveBrokers/Client/ExecutionDetailsEventArgs.cs
@@ -1,11 +1,11 @@
 /*
  * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
  * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,17 +26,17 @@ namespace QuantConnect.Brokerages.InteractiveBrokers.Client
         /// <summary>
         /// The request's identifier.
         /// </summary>
-        public int RequestId { get; private set; }
+        public int RequestId { get; }
 
         /// <summary>
         /// This structure contains a full description of the contract that was executed.
         /// </summary>
-        public Contract Contract { get; private set; }
+        public Contract Contract { get; }
 
         /// <summary>
         /// This structure contains addition order execution details.
         /// </summary>
-        public Execution Execution { get; private set; }
+        public Execution Execution { get; }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="ExecutionDetailsEventArgs"/> class
@@ -53,9 +53,7 @@ namespace QuantConnect.Brokerages.InteractiveBrokers.Client
         /// </summary>
         public override string ToString()
         {
-            return string.Format(
-                "RequestId: {0}, Symbol: {1}, OrderId: {2}, Time: {3}, Side: {4}, Shares: {5}, Price: {6}, CumQty: {7}, PermId: {8}",
-                RequestId, Contract.Symbol, Execution.OrderId, Execution.Time, Execution.Side, Execution.Shares, Execution.Price, Execution.CumQty, Execution.PermId);
+            return $"RequestId: {RequestId}, Symbol: {Contract.Symbol}, OrderId: {Execution.OrderId}, Time: {Execution.Time}, Side: {Execution.Side}, Shares: {Execution.Shares}, Price: {Execution.Price}, CumQty: {Execution.CumQty}, PermId: {Execution.PermId}, Account: {Execution.AcctNumber}";
         }
     }
 }
\ No newline at end of file

ATOMIC:	YES


PROJECT:	Lean
SHA:	9e54be123f9458680879b4f6a8e58cdbd8dcb2a3
DIFF:
commit 9e54be123f9458680879b4f6a8e58cdbd8dcb2a3
Author: Stefano Raggi <stefano.raggi67@gmail.com>
Date:   Tue Nov 14 20:39:49 2017 +0100

    Add time range check in ApplyUniverseSelection

diff --git a/Common/Data/UniverseSelection/Universe.cs b/Common/Data/UniverseSelection/Universe.cs
index 9b087b40..eaf029b7 100644
--- a/Common/Data/UniverseSelection/Universe.cs
+++ b/Common/Data/UniverseSelection/Universe.cs
@@ -1,11 +1,11 @@
 ﻿/*
  * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
  * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/Engine/DataFeeds/UniverseSelection.cs b/Engine/DataFeeds/UniverseSelection.cs
index 688058cf..7d1f6fc9 100644
--- a/Engine/DataFeeds/UniverseSelection.cs
+++ b/Engine/DataFeeds/UniverseSelection.cs
@@ -1,11 +1,11 @@
 ﻿/*
  * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
  * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); 
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -62,6 +62,12 @@ namespace QuantConnect.Lean.Engine.DataFeeds
         /// <param name="universeData">The data provided to perform selection with</param>
         public SecurityChanges ApplyUniverseSelection(Universe universe, DateTime dateTimeUtc, BaseDataCollection universeData)
         {
+            var algorithmEndDateUtc = _algorithm.EndDate.ConvertToUtc(_algorithm.TimeZone);
+            if (dateTimeUtc > algorithmEndDateUtc)
+            {
+                return SecurityChanges.None;
+            }
+
             IEnumerable<Symbol> selectSymbolsResult;
 
             // check if this universe must be filtered with fine fundamental data
@@ -116,7 +122,6 @@ namespace QuantConnect.Lean.Engine.DataFeeds
 
             var additions = new List<Security>();
             var removals = new List<Security>();
-            var algorithmEndDateUtc = _algorithm.EndDate.ConvertToUtc(_algorithm.TimeZone);
 
             // remove previously deselected members which were kept in the universe because of holdings or open orders
             foreach (var member in _pendingRemovals.ToList())

ATOMIC:	YES


PROJECT:	Newtonsoft.Json
SHA:	0bf5f27f2fd4f9bd48b426272772adfc204619eb
DIFF:
commit 0bf5f27f2fd4f9bd48b426272772adfc204619eb
Author: James Newton-King <james@newtonking.com>
Date:   Mon Sep 24 21:12:42 2012 +1200

    -Improved duplicate object reference id error message

diff --git a/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs b/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
index 1b5c059e..e958273c 100644
--- a/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
+++ b/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
@@ -76,5 +76,5 @@
 // by using the '*' as shown below:
 [assembly: AssemblyVersion("4.5.0.0")]
 #if !PocketPC
-[assembly: AssemblyFileVersion("4.5.9.15313")]
+[assembly: AssemblyFileVersion("4.5.9.15324")]
 #endif
diff --git a/Src/Newtonsoft.Json.Tests/Serialization/PreserveReferencesHandlingTests.cs b/Src/Newtonsoft.Json.Tests/Serialization/PreserveReferencesHandlingTests.cs
index 5bc7fa46..beb5ea66 100644
--- a/Src/Newtonsoft.Json.Tests/Serialization/PreserveReferencesHandlingTests.cs
+++ b/Src/Newtonsoft.Json.Tests/Serialization/PreserveReferencesHandlingTests.cs
@@ -26,6 +26,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.Serialization.Formatters;
 using System.Text;
 using Newtonsoft.Json.Linq;
 using Newtonsoft.Json.Tests.TestObjects;
@@ -1055,6 +1056,27 @@ public void PropertyItemIsReferenceObject()
       Assert.IsTrue(ReferenceEquals(c2, c3));
       Assert.IsFalse(ReferenceEquals(c2, c4));
     }
+
+    [Test]
+    public void DuplicateId()
+    {
+      string json = @"{
+  ""Data"": {
+    ""Prop1"": {
+      ""$id"": ""1"",
+      ""MyProperty"": 0
+    },
+    ""Prop2"": {
+      ""$id"": ""1"",
+      ""MyProperty"": 0
+    }
+  }
+}";
+
+      ExceptionAssert.Throws<JsonSerializationException>(
+        "Error reading object reference '1'. Path 'Data.Prop2.MyProperty', line 9, position 20.",
+        () => JsonConvert.DeserializeObject<PropertyItemIsReferenceObject>(json));
+    }
   }
 
   public class PropertyItemIsReferenceBody
diff --git a/Src/Newtonsoft.Json/Converters/StringEnumConverter.cs b/Src/Newtonsoft.Json/Converters/StringEnumConverter.cs
index 59ac00b2..c1f02694 100644
--- a/Src/Newtonsoft.Json/Converters/StringEnumConverter.cs
+++ b/Src/Newtonsoft.Json/Converters/StringEnumConverter.cs
@@ -169,7 +169,7 @@ public override object ReadJson(JsonReader reader, Type objectType, object exist
                 .FormatWith(CultureInfo.InvariantCulture, n2, t.Name));
             }
 
-            map.Add(n1, n2);
+            map.Set(n1, n2);
           }
 
           _enumMemberNamesPerType[t] = map;
diff --git a/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs b/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
index afd5f6cd..dcb0baa9 100644
--- a/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
+++ b/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
@@ -90,7 +90,7 @@
 // by using the '*' as shown below:
 [assembly: AssemblyVersion("4.5.0.0")]
 #if !PocketPC
-[assembly: AssemblyFileVersion("4.5.9.15313")]
+[assembly: AssemblyFileVersion("4.5.9.15324")]
 #endif
 
 [assembly: CLSCompliant(true)]
diff --git a/Src/Newtonsoft.Json/Serialization/DefaultReferenceResolver.cs b/Src/Newtonsoft.Json/Serialization/DefaultReferenceResolver.cs
index 02bb1893..ceb86b80 100644
--- a/Src/Newtonsoft.Json/Serialization/DefaultReferenceResolver.cs
+++ b/Src/Newtonsoft.Json/Serialization/DefaultReferenceResolver.cs
@@ -63,7 +63,7 @@ public string GetReference(object context, object value)
       {
         _referenceCount++;
         reference = _referenceCount.ToString(CultureInfo.InvariantCulture);
-        mappings.Add(reference, value);
+        mappings.Set(reference, value);
       }
 
       return reference;
@@ -71,7 +71,7 @@ public string GetReference(object context, object value)
 
     public void AddReference(object context, string reference, object value)
     {
-      GetMappings(context).Add(reference, value);
+      GetMappings(context).Set(reference, value);
     }
 
     public bool IsReferenced(object context, object value)
diff --git a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalBase.cs b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalBase.cs
index 145ac856..dda63122 100644
--- a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalBase.cs
+++ b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalBase.cs
@@ -73,7 +73,9 @@ protected JsonSerializerInternalBase(JsonSerializer serializer)
         if (_mappings == null)
           _mappings = new BidirectionalDictionary<string, object>(
             EqualityComparer<string>.Default,
-            new ReferenceEqualsEqualityComparer());
+            new ReferenceEqualsEqualityComparer(),
+            "A different value already has the Id '{0}'.",
+            "A different Id has already been assigned for value '{0}'.");
 
         return _mappings;
       }
diff --git a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalReader.cs b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalReader.cs
index 6fc3f9d0..c753fbea 100644
--- a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalReader.cs
+++ b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalReader.cs
@@ -761,6 +761,18 @@ private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter p
       return false;
     }
 
+    private void AddReference(JsonReader reader, string id, object value)
+    {
+      try
+      {
+        Serializer.ReferenceResolver.AddReference(this, id, value);
+      }
+      catch (Exception ex)
+      {
+        throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
+      }
+    }
+
     private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
     {
       return ((value & flag) == flag);
@@ -799,7 +811,7 @@ private object PopulateDictionary(IWrappedDictionary wrappedDictionary, JsonRead
       object dictionary = wrappedDictionary.UnderlyingDictionary;
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, dictionary);
+        AddReference(reader, id, dictionary);
 
       contract.InvokeOnDeserializing(dictionary, Serializer.Context);
 
@@ -872,7 +884,7 @@ private object PopulateMultidimensionalArray(IList list, JsonReader reader, Json
       int rank = contract.UnderlyingType.GetArrayRank();
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, list);
+        AddReference(reader, id, list);
 
       contract.InvokeOnDeserializing(list, Serializer.Context);
 
@@ -1010,7 +1022,7 @@ private object PopulateList(IWrappedCollection wrappedList, JsonReader reader, J
       object list = wrappedList.UnderlyingCollection;
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, list);
+        AddReference(reader, id, list);
 
       // can't populate an existing array
       if (wrappedList.IsFixedSize)
@@ -1137,7 +1149,7 @@ private object CreateISerializable(JsonReader reader, JsonISerializableContract
       object createdObject = contract.ISerializableCreator(serializationInfo, Serializer.Context);
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, createdObject);
+        AddReference(reader, id, createdObject);
 
       // these are together because OnDeserializing takes an object but for an ISerializable the object is fully created in the constructor
       contract.InvokeOnDeserializing(createdObject, Serializer.Context);
@@ -1162,7 +1174,7 @@ private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, Js
         throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, newObject);
+        AddReference(reader, id, newObject);
 
       contract.InvokeOnDeserializing(newObject, Serializer.Context);
 
@@ -1257,7 +1269,7 @@ private object CreateObjectFromNonDefaultConstructor(JsonReader reader, JsonObje
       object createdObject = constructorInfo.Invoke(constructorParameters.Values.ToArray());
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, createdObject);
+        AddReference(reader, id, createdObject);
 
       contract.InvokeOnDeserializing(createdObject, Serializer.Context);
 
@@ -1478,7 +1490,7 @@ private object PopulateObject(object newObject, JsonReader reader, JsonObjectCon
         : null;
 
       if (id != null)
-        Serializer.ReferenceResolver.AddReference(this, id, newObject);
+        AddReference(reader, id, newObject);
 
       int initialDepth = reader.Depth;
 
diff --git a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalWriter.cs b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalWriter.cs
index c1a4bdbf..25244b37 100644
--- a/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalWriter.cs
+++ b/Src/Newtonsoft.Json/Serialization/JsonSerializerInternalWriter.cs
@@ -254,10 +254,23 @@ private void WriteReference(JsonWriter writer, object value)
     {
       writer.WriteStartObject();
       writer.WritePropertyName(JsonTypeReflector.RefPropertyName);
-      writer.WriteValue(Serializer.ReferenceResolver.GetReference(this, value));
+      writer.WriteValue(GetReference(writer, value));
       writer.WriteEndObject();
     }
 
+    private string GetReference(JsonWriter writer, object value)
+    {
+      try
+      {
+        string reference = Serializer.ReferenceResolver.GetReference(this, value);
+        return reference;
+      }
+      catch (Exception ex)
+      {
+        throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
+      }
+    }
+
     internal static bool TryConvertToString(object value, Type type, out string s)
     {
 #if !(PocketPC || NETFX_CORE || PORTABLE)
@@ -397,7 +410,7 @@ private void WriteObjectStart(JsonWriter writer, object value, JsonContract cont
       if (isReference)
       {
         writer.WritePropertyName(JsonTypeReflector.IdPropertyName);
-        writer.WriteValue(Serializer.ReferenceResolver.GetReference(this, value));
+        writer.WriteValue(GetReference(writer, value));
       }
       if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
       {
@@ -584,7 +597,7 @@ private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract
         if (isReference)
         {
           writer.WritePropertyName(JsonTypeReflector.IdPropertyName);
-          writer.WriteValue(Serializer.ReferenceResolver.GetReference(this, values));
+          writer.WriteValue(GetReference(writer, values));
         }
         if (includeTypeDetails)
         {
diff --git a/Src/Newtonsoft.Json/Utilities/BidirectionalDictionary.cs b/Src/Newtonsoft.Json/Utilities/BidirectionalDictionary.cs
index 19c8a985..37ecaa4b 100644
--- a/Src/Newtonsoft.Json/Utilities/BidirectionalDictionary.cs
+++ b/Src/Newtonsoft.Json/Utilities/BidirectionalDictionary.cs
@@ -25,6 +25,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 
 namespace Newtonsoft.Json.Utilities
 {
@@ -32,6 +33,8 @@ internal class BidirectionalDictionary<TFirst, TSecond>
   {
     private readonly IDictionary<TFirst, TSecond> _firstToSecond;
     private readonly IDictionary<TSecond, TFirst> _secondToFirst;
+    private readonly string _duplicateFirstErrorMessage;
+    private readonly string _duplicateSecondErrorMessage;
 
     public BidirectionalDictionary()
       : this(EqualityComparer<TFirst>.Default, EqualityComparer<TSecond>.Default)
@@ -39,17 +42,40 @@ public BidirectionalDictionary()
     }
 
     public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
+      : this(
+          firstEqualityComparer,
+          secondEqualityComparer,
+          "Duplicate item already exists for '{0}'.",
+          "Duplicate item already exists for '{0}'.")
+    {
+    }
+
+    public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer,
+      string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
     {
       _firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
       _secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
+      _duplicateFirstErrorMessage = duplicateFirstErrorMessage;
+      _duplicateSecondErrorMessage = duplicateSecondErrorMessage;
     }
 
-    public void Add(TFirst first, TSecond second)
+    public void Set(TFirst first, TSecond second)
     {
-      if (_firstToSecond.ContainsKey(first) || _secondToFirst.ContainsKey(second))
+      TFirst existingFirst;
+      TSecond existingSecond;
+
+      if (_firstToSecond.TryGetValue(first, out existingSecond))
       {
-        throw new ArgumentException("Duplicate first or second");
+        if (!existingSecond.Equals(second))
+          throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
       }
+
+      if (_secondToFirst.TryGetValue(second, out existingFirst))
+      {
+        if (!existingFirst.Equals(first))
+          throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
+      }
+
       _firstToSecond.Add(first, second);
       _secondToFirst.Add(second, first);
     }

ATOMIC:	NO, dependencies are updated, not visible in PDG.


PROJECT:	RestSharp
SHA:	d086b47c5f53159c8abc046975ae0688ace00b14
DIFF:
commit d086b47c5f53159c8abc046975ae0688ace00b14
Author: Phil Haack <haacked@gmail.com>
Date:   Fri Oct 18 15:29:26 2013 -0700

    Increment RestSharp PATCH version

diff --git a/RestSharp/SharedAssemblyInfo.cs b/RestSharp/SharedAssemblyInfo.cs
index 51b1174..7ba65ad 100644
--- a/RestSharp/SharedAssemblyInfo.cs
+++ b/RestSharp/SharedAssemblyInfo.cs
@@ -30,5 +30,5 @@
 
 class SharedAssembylInfo
 {
-    public const string Version = "104.3.0";
+    public const string Version = "104.3.1";
 }

ATOMIC:	YES


PROJECT:	RestSharp
SHA:	6e306011691e5ecf1306d64cddb65dcde0f7ee98
DIFF:
commit 6e306011691e5ecf1306d64cddb65dcde0f7ee98
Author: johnsheehan <johnsheehan@gmail.com>
Date:   Sun Jul 25 15:13:53 2010 -0600

    More exception handling for Aysnc (issue 41)

diff --git a/RestSharp/Http.Async.cs b/RestSharp/Http.Async.cs
index a81f333..8653340 100644
--- a/RestSharp/Http.Async.cs
+++ b/RestSharp/Http.Async.cs
@@ -75,18 +75,37 @@ public void PutAsync(Action<HttpResponse> action)
 
 		private void GetStyleMethodInternalAsync(string method, Action<HttpResponse> callback)
 		{
-			var webRequest = ConfigureAsyncWebRequest(method, Url);
-			webRequest.BeginGetResponse(result => ResponseCallback(result, callback), webRequest);
+			try
+			{
+				var webRequest = ConfigureAsyncWebRequest(method, Url);
+				webRequest.BeginGetResponse(result => ResponseCallback(result, callback), webRequest);
+			}
+			catch (Exception ex)
+			{
+				var response = new HttpResponse();
+				response.ErrorMessage = ex.Message;
+				response.ErrorException = ex;
+				response.ResponseStatus = ResponseStatus.Error;
+				callback(response);
+			}
 		}
 
 		private void PutPostInternalAsync(string method, Action<HttpResponse> callback)
 		{
-			var webRequest = ConfigureAsyncWebRequest(method, Url);
-
-			PreparePostBody(webRequest);
-
-			WriteRequestBodyAsync(webRequest, callback);
-
+			try
+			{
+				var webRequest = ConfigureAsyncWebRequest(method, Url);
+				PreparePostBody(webRequest);
+				WriteRequestBodyAsync(webRequest, callback);
+			}
+			catch (Exception ex)
+			{
+				var response = new HttpResponse();
+				response.ErrorMessage = ex.Message;
+				response.ErrorException = ex;
+				response.ResponseStatus = ResponseStatus.Error;
+				callback(response);
+			}
 		}
 
 		private void WriteRequestBodyAsync(HttpWebRequest webRequest, Action<HttpResponse> callback)

ATOMIC:	YES


PROJECT:	Hangfire
SHA:	796064f42da2c94006ce6eaadb4ab823d4b16275
DIFF:
commit 796064f42da2c94006ce6eaadb4ab823d4b16275
Author: Sergey Odinokov <odinserj@gmail.com>
Date:   Sat Oct 26 15:01:01 2013 +0400

    Test for custom TypeConverter

diff --git a/HangFire.Tests/Bindings/ClientSteps.cs b/HangFire.Tests/Bindings/ClientSteps.cs
index c62e618b..816b48a2 100644
--- a/HangFire.Tests/Bindings/ClientSteps.cs
+++ b/HangFire.Tests/Bindings/ClientSteps.cs
@@ -16,6 +16,11 @@ public void GivenTheJobType(string typeDefinition)
         {
         }
 
+        [Given(@"the custom types:")]
+        public void GivenTheCustomTypes(string typeDefinition)
+        {
+        }
+
         [When(@"I call the `(.+)`")]
         public void WhenICallThe(string code)
         {
@@ -73,6 +78,10 @@ public void WhenICallThe(string code)
                 {
                     _jobId = Perform.Async<EmptyQueueJob>();
                 }
+                else if (code.Equals("Perform.Async<TestJob>(new { Author = new CustomType() })"))
+                {
+                    _jobId = Perform.Async<TestJob>(new { Author = new CustomType() });
+                }
                 else
                 {
                     ScenarioContext.Current.Pending();
diff --git a/HangFire.Tests/Bindings/JobClientSteps.cs b/HangFire.Tests/Bindings/JobClientSteps.cs
index dd2c225a..2de4b0d8 100644
--- a/HangFire.Tests/Bindings/JobClientSteps.cs
+++ b/HangFire.Tests/Bindings/JobClientSteps.cs
@@ -156,26 +156,26 @@ public void WhenICreateAJobWithTheIncorrectType()
             }
         }
 
-        [Then("the storage contains the job")]
+        [Then("the storage should contain the job")]
         public void ThenTheStorageContainsIt()
         {
             Assert.IsTrue(Redis.Client.ContainsKey("hangfire:job:" + JobSteps.DefaultJobId));
         }
 
-        [Then("the storage does not contain the job")]
+        [Then("the storage should not contain the job")]
         public void ThenTheStorageDoesNotContainTheJob()
         {
             Assert.IsFalse(Redis.Client.ContainsKey("hangfire:job:" + JobSteps.DefaultJobId));
         }
 
-        [Then("it has the following parameters:")]
+        [Then("it should have the following parameters:")]
         public void ThenItHasTheFollowingParameters(Table table)
         {
             var job = Redis.Client.GetAllEntriesFromHash("hangfire:job:" + JobSteps.DefaultJobId);
             DictionaryAssert.ContainsFollowingItems(table, job);
         }
 
-        [Then("the job contains all of the above arguments in the JSON format")]
+        [Then("the job should contain all of the above arguments in the JSON format")]
         public void ThenTheJobContainsAllOfTheAboveArguments()
         {
             var argsJson = Redis.Client.GetValueFromHash(
@@ -191,7 +191,7 @@ public void ThenTheJobContainsAllOfTheAboveArguments()
             }
         }
 
-        [Then("the given state was applied to it")]
+        [Then("the given state should be applied to it")]
         public void ThenTheGivenStateWasAppliedToIt()
         {
             _stateMock.Verify(
@@ -199,23 +199,22 @@ public void ThenTheGivenStateWasAppliedToIt()
                 Times.Once);
         }
 
-        [Then("a '(.+)' was thrown")]
-        [Then("a '(.+)' is thrown")]
+        [Then("a '(.+)' should be thrown by the client")]
         public void ThenAnExceptionIsThrown(string exceptionType)
         {
             Assert.IsNotNull(_exception);
             Assert.IsInstanceOfType(_exception, Type.GetType(exceptionType, true));
         }
 
-        [Then("the CreateJobFailedException was thrown")]
+        [Then("the CreateJobFailedException should be thrown by the client")]
         public void ThenTheCreateJobFailedExceptionWasThrown()
         {
             Assert.IsNotNull(_exception);
             Assert.IsInstanceOfType(_exception, typeof(CreateJobFailedException));
         }
 
-        [Then("only the following client filter methods were executed:")]
-        [Then("the client filter methods were executed in the following order:")]
+        [Then("only the following client filter methods should be executed:")]
+        [Then("the client filter methods should be executed in the following order:")]
         public void ThenTheClientFilterMethodsWereExecuted(Table table)
         {
             Assert.AreEqual(table.RowCount, _clientFilterResults.Count);
@@ -227,14 +226,14 @@ public void ThenTheClientFilterMethodsWereExecuted(Table table)
             }
         }
 
-        [Then("the client exception filter was executed")]
+        [Then("the client exception filter should be executed")]
         public void ThenTheClientFilterWasExecuted()
         {
             Assert.AreNotEqual(0, _exceptionFilterResults.Count);
         }
 
-        [Then("the following exceptions filter were executed:")]
-        [Then("the client exception filters were executed in the following order:")]
+        [Then("the following client exception filters should be executed:")]
+        [Then("the client exception filters should be executed in the following order:")]
         public void ThenTheClientExceptionFiltersWereExecuted(Table table)
         {
             Assert.AreEqual(table.RowCount, _exceptionFilterResults.Count);
@@ -246,7 +245,7 @@ public void ThenTheClientExceptionFiltersWereExecuted(Table table)
             }
         }
 
-        [Then("no exception were thrown")]
+        [Then("an exception should not be thrown by the client")]
         public void ThenNoExceptionWereThrown()
         {
             Assert.IsNull(_exception);
diff --git a/HangFire.Tests/Client.feature b/HangFire.Tests/Client.feature
index 1d408cd6..ed6ab0a5 100644
--- a/HangFire.Tests/Client.feature
+++ b/HangFire.Tests/Client.feature
@@ -31,6 +31,23 @@ Scenario: the `Perform.Async<TJob>(object args)` method should enqueue job with
           | ArticleId | 3        |
           | Author    | odinserj |
 
+Scenario: When one or more of the job arguments can not be converted using the custom TypeConverter, an exception should be raised
+    Given the custom types:
+          """ 
+          [TypeConverter(typeof(CustomTypeConverter))
+          public class CustomType {}
+
+          public class CustomTypeConverter : TypeConverter
+          {
+              public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
+              {
+                  throw new NotSupportedException();
+              }
+          }
+          """
+     When I call the `Perform.Async<TestJob>(new { Author = new CustomType() })`
+     Then a 'System.InvalidOperationException' should be thrown
+
 Scenario: the `Perform.Async(Type type)` method should enqueue a job of the given type
      When I call the `Perform.Async(typeof(TestJob))`
      Then the argumentless 'TestJob' should be added to the default queue
diff --git a/HangFire.Tests/Client.feature.cs b/HangFire.Tests/Client.feature.cs
index ebfb1e24..865c27f7 100644
--- a/HangFire.Tests/Client.feature.cs
+++ b/HangFire.Tests/Client.feature.cs
@@ -130,6 +130,39 @@ public virtual void ThePerform_AsyncTJobObjectArgsMethodShouldEnqueueJobWithTheG
             this.ScenarioCleanup();
         }
         
+        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute()]
+        [Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("When one or more of the job arguments can not be converted using the custom TypeC" +
+            "onverter, an exception should be raised")]
+        [Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Client")]
+        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("redis")]
+        public virtual void WhenOneOrMoreOfTheJobArgumentsCanNotBeConvertedUsingTheCustomTypeConverterAnExceptionShouldBeRaised()
+        {
+            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("When one or more of the job arguments can not be converted using the custom TypeC" +
+                    "onverter, an exception should be raised", ((string[])(null)));
+#line 34
+this.ScenarioSetup(scenarioInfo);
+#line 6
+this.FeatureBackground();
+#line hidden
+#line 35
+    testRunner.Given("the custom types:", @"[TypeConverter(typeof(CustomTypeConverter))
+public class CustomType {}
+
+public class CustomTypeConverter : TypeConverter
+{
+    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
+    {
+        throw new NotSupportedException();
+    }
+}", ((TechTalk.SpecFlow.Table)(null)), "Given ");
+#line 48
+     testRunner.When("I call the `Perform.Async<TestJob>(new { Author = new CustomType() })`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
+#line 49
+     testRunner.Then("a \'System.InvalidOperationException\' should be thrown", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
+#line hidden
+            this.ScenarioCleanup();
+        }
+        
         [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute()]
         [Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("the `Perform.Async(Type type)` method should enqueue a job of the given type")]
         [Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Client")]
@@ -137,13 +170,13 @@ public virtual void ThePerform_AsyncTJobObjectArgsMethodShouldEnqueueJobWithTheG
         public virtual void ThePerform_AsyncTypeTypeMethodShouldEnqueueAJobOfTheGivenType()
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.Async(Type type)` method should enqueue a job of the given type", ((string[])(null)));
-#line 34
+#line 51
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 35
+#line 52
      testRunner.When("I call the `Perform.Async(typeof(TestJob))`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 36
+#line 53
      testRunner.Then("the argumentless \'TestJob\' should be added to the default queue", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -158,13 +191,13 @@ public virtual void PassingTheNullTypeArgumentToThePerform_AsyncTypeTypeMethodSh
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Passing the null type argument to the `Perform.Async(Type type)` method should ca" +
                     "use exception", ((string[])(null)));
-#line 38
+#line 55
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 39
+#line 56
      testRunner.When("I call the `Perform.Async(null)`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 40
+#line 57
      testRunner.Then("a \'System.ArgumentNullException\' should be thrown", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -179,11 +212,11 @@ public virtual void ThePerform_AsyncTypeTypeObjectArgsMethodShouldEnqueueJobOfTh
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.Async(Type type, object args)` method should enqueue job of the give" +
                     "n type", ((string[])(null)));
-#line 42
+#line 59
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 43
+#line 60
      testRunner.When("I call the `Perform.Async(typeof(TestJob), new { ArticleId = 3 })`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
 #line hidden
             TechTalk.SpecFlow.Table table2 = new TechTalk.SpecFlow.Table(new string[] {
@@ -192,7 +225,7 @@ public virtual void ThePerform_AsyncTypeTypeObjectArgsMethodShouldEnqueueJobOfTh
             table2.AddRow(new string[] {
                         "ArticleId",
                         "3"});
-#line 44
+#line 61
      testRunner.Then("the \'TestJob\' should be added to the default queue with the following arguments:", ((string)(null)), table2, "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -207,13 +240,13 @@ public virtual void PassingTheNullTypeArgumentToThePerform_AsyncTypeTypeObjectAr
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Passing the null type argument to the `Perform.Async(Type type, object args)` met" +
                     "hod should cause exception", ((string[])(null)));
-#line 48
+#line 65
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 49
+#line 66
      testRunner.When("I call the `Perform.Async(null, new { ArticleId = 3 })`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 50
+#line 67
      testRunner.Then("a \'System.ArgumentNullException\' should be thrown", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -226,17 +259,17 @@ public virtual void PassingTheNullTypeArgumentToThePerform_AsyncTypeTypeObjectAr
         public virtual void ThePerform_AsyncTJobMethodShouldEnqueueAJobToItsActualQueue()
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.Async<TJob>()` method should enqueue a job to its actual queue", ((string[])(null)));
-#line 55
+#line 72
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
 #line hidden
-#line 56
+#line 73
     testRunner.Given("the following job type:", "[Queue(\"critical\")]\r\npublic class CriticalQueueJob : BackgroundJob\r\n{\r\n    public" +
                     " override void Perform()\r\n    {\r\n    }\r\n}", ((TechTalk.SpecFlow.Table)(null)), "Given ");
-#line 66
+#line 83
      testRunner.When("I call the `Perform.Async<CriticalQueueJob>()`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 67
+#line 84
      testRunner.Then("the argumentless \'CriticalQueueJob\' should be added to the \'critical\' queue", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -249,17 +282,17 @@ public virtual void ThePerform_AsyncTJobMethodShouldEnqueueAJobToItsActualQueue(
         public virtual void TheQueueNameShouldContainOnlyLowercaseLettersDigitsAndUnderscores()
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the queue name should contain only lowercase letters, digits and underscores", ((string[])(null)));
-#line 69
+#line 86
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
 #line hidden
-#line 70
+#line 87
     testRunner.Given("the following job type:", "[Queue(\" $InvalidQueue\")]\r\npublic class InvalidQueueJob : BackgroundJob\r\n{\r\n    p" +
                     "ublic override void Perform()\r\n    {\r\n    }\r\n}", ((TechTalk.SpecFlow.Table)(null)), "Given ");
-#line 80
+#line 97
      testRunner.When("I call the `Perform.Async<InvalidQueueJob>()`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 81
+#line 98
      testRunner.Then("a \'System.InvalidOperationException\' should be thrown", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -274,17 +307,17 @@ public virtual void IfTheQueueAttributeContainsAnEmptyOrNullStringThenTheActualQ
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("if the QueueAttribute contains an empty or null string, then the actual queue sho" +
                     "uld be the default queue", ((string[])(null)));
-#line 83
+#line 100
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
 #line hidden
-#line 84
+#line 101
     testRunner.Given("the following job type:", "[Queue(\"\")]\r\npublic class EmptyQueueJob : BackgroundJob\r\n{\r\n    public override v" +
                     "oid Perform()\r\n    {\r\n    }\r\n}", ((TechTalk.SpecFlow.Table)(null)), "Given ");
-#line 94
+#line 111
      testRunner.When("I call the `Perform.Async<EmptyQueueJob>()`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 95
+#line 112
      testRunner.Then("the argumentless \'EmptyQueueJob\' should be added to the default queue", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -299,13 +332,13 @@ public virtual void ThePerform_InTestJobTimeSpanDelayMethodShouldScheduleAJobOfT
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.In<TestJob>(TimeSpan delay)` method should schedule a job of the giv" +
                     "en type", ((string[])(null)));
-#line 100
+#line 117
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 101
+#line 118
      testRunner.When("I call the `Perform.In<TestJob>(TimeSpan.FromDays(1))`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 102
+#line 119
      testRunner.Then("the argumentless \'TestJob\' should be scheduled for tomorrow", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -320,11 +353,11 @@ public virtual void ThePerform_InTestJobTimeSpanDelayObjectArgsMethodShouldSched
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.In<TestJob>(TimeSpan delay, object args)` method should schedule a j" +
                     "ob of the given type", ((string[])(null)));
-#line 104
+#line 121
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 105
+#line 122
      testRunner.When("I call the `Perform.In<TestJob>(TimeSpan.FromDays(1), new { ArticleId = 3 })`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
 #line hidden
             TechTalk.SpecFlow.Table table3 = new TechTalk.SpecFlow.Table(new string[] {
@@ -333,7 +366,7 @@ public virtual void ThePerform_InTestJobTimeSpanDelayObjectArgsMethodShouldSched
             table3.AddRow(new string[] {
                         "ArticleId",
                         "3"});
-#line 106
+#line 123
      testRunner.Then("the \'TestJob\' should be scheduled for tomorrow with the following arguments:", ((string)(null)), table3, "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -348,13 +381,13 @@ public virtual void ThePerform_InTimeSpanDelayTypeTypeMethodShouldScheduleAJobOf
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("the `Perform.In(TimeSpan delay, Type type)` method should schedule a job of the g" +
                     "iven type", ((string[])(null)));
-#line 110
+#line 127
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 111
+#line 128
      testRunner.When("I call the `Perform.In(TimeSpan.FromDays(1), typeof(TestJob))`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
-#line 112
+#line 129
      testRunner.Then("the argumentless \'TestJob\' should be scheduled for tomorrow", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
 #line hidden
             this.ScenarioCleanup();
@@ -369,11 +402,11 @@ public virtual void ThePerform_InTimeSpanDelayTypeTypeObjectArgsMethodShouldSche
         {
             TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("The `Perform.In(TimeSpan delay, Type type, object args)` method should schedule a" +
                     " job of the given type", ((string[])(null)));
-#line 114
+#line 131
 this.ScenarioSetup(scenarioInfo);
 #line 6
 this.FeatureBackground();
-#line 115
+#line 132
      testRunner.When("I call the `Perform.In(TimeSpan.FromDays(1), typeof(TestJob), new { ArticleId = 3" +
                     " })`", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
 #line hidden
@@ -383,7 +416,7 @@ public virtual void ThePerform_InTimeSpanDelayTypeTypeObjectArgsMethodShouldSche
             table4.AddRow(new string[] {
                         "ArticleId",
                         "3"});
-#line 116
+#line 133
      testRunner.Then("the \'TestJob\' should be scheduled for tomorrow with the following arguments:", ((string)(null)), table4, "Then ");
 #line hidden
             this.ScenarioCleanup();
diff --git a/HangFire.Tests/Common/CustomType.cs b/HangFire.Tests/Common/CustomType.cs
new file mode 100644
index 00000000..01d33eee
--- /dev/null
+++ b/HangFire.Tests/Common/CustomType.cs
@@ -0,0 +1,7 @@
+﻿using System.ComponentModel;
+
+namespace HangFire.Tests
+{
+    [TypeConverter(typeof(CustomTypeConverter))]
+    public class CustomType {}
+}
\ No newline at end of file
diff --git a/HangFire.Tests/Common/CustomTypeConverter.cs b/HangFire.Tests/Common/CustomTypeConverter.cs
new file mode 100644
index 00000000..2e7ea819
--- /dev/null
+++ b/HangFire.Tests/Common/CustomTypeConverter.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.ComponentModel;
+using System.Globalization;
+
+namespace HangFire.Tests
+{
+    public class CustomTypeConverter : TypeConverter
+    {
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
+        {
+            throw new NotSupportedException();
+        }
+    }
+}
\ No newline at end of file
diff --git a/HangFire.Tests/HangFire.Tests.csproj b/HangFire.Tests/HangFire.Tests.csproj
index 13c59423..e827c29a 100644
--- a/HangFire.Tests/HangFire.Tests.csproj
+++ b/HangFire.Tests/HangFire.Tests.csproj
@@ -93,6 +93,8 @@
     <Compile Include="Common\BrokenJob.cs" />
     <Compile Include="Common\CriticalQueueJob.cs" />
     <Compile Include="Common\CustomConstructorJob.cs" />
+    <Compile Include="Common\CustomType.cs" />
+    <Compile Include="Common\CustomTypeConverter.cs" />
     <Compile Include="Common\EmptyQueueJob.cs" />
     <Compile Include="Common\InvalidQueueJob.cs" />
     <Compile Include="Common\TestExceptionFilter.cs" />

ATOMIC:	YES


PROJECT:	Lean
SHA:	4aed8f79a0f18c18a8ca015d67f4f89648933357
DIFF:
commit 4aed8f79a0f18c18a8ca015d67f4f89648933357
Author: snugs <mhandschuh@gmail.com>
Date:   Tue Feb 17 00:00:56 2015 -0500

    BrokerageSetupHandler initializes portfolio holdings

diff --git a/Engine/Setup/BrokerageSetupHandler.cs b/Engine/Setup/BrokerageSetupHandler.cs
index 8db4c3a4..85c09233 100644
--- a/Engine/Setup/BrokerageSetupHandler.cs
+++ b/Engine/Setup/BrokerageSetupHandler.cs
@@ -129,6 +129,13 @@ namespace QuantConnect.Lean.Engine.Setup
                     order.Id = algorithm.Transactions.GetIncrementOrderId();
                     algorithm.Orders.AddOrUpdate(order.Id, order, (i, o) => order);
                 }
+
+                // populate the algorihtm with the account's current holdings
+                var holdings = brokerage.GetAccountHoldings();
+                foreach (var holding in holdings)
+                {
+                    algorithm.Portfolio[holding.Symbol].SetHoldings(holding.AveragePrice, (int)holding.Quantity);
+                }
             }
             catch (Exception err)
             {

ATOMIC:	YES


PROJECT:	Commandline
SHA:	bcf133cbcb8e828e3b5db83d57772ecb4ab57d26
DIFF:
commit bcf133cbcb8e828e3b5db83d57772ecb4ab57d26
Author: Giacomo Stelluti Scala <gsscoder@gmail.com>
Date:   Tue Jul 21 14:49:46 2015 +0200

    Chaining m. and adding MapIf() in AddOptionName()

diff --git a/src/CommandLine/Text/HelpText.cs b/src/CommandLine/Text/HelpText.cs
index 9fbd198..43539b9 100644
--- a/src/CommandLine/Text/HelpText.cs
+++ b/src/CommandLine/Text/HelpText.cs
@@ -666,23 +666,22 @@ namespace CommandLine.Text
 
         private string AddOptionName(int maxLength, OptionSpecification specification)
         {
-            var optionName = new StringBuilder(maxLength);
-            if (specification.ShortName.Length > 0)
-            {
-                optionName
-                    .AppendWhen(addDashesToOption, '-')
-                    .AppendFormat("{0}", specification.ShortName)
-                    .AppendFormatWhen(specification.MetaValue.Length > 0, " {0}", specification.MetaValue)
-                    .AppendWhen(specification.LongName.Length > 0, ", ");
-            }
-            if (specification.LongName.Length > 0)
-            {
-                optionName
-                    .AppendWhen(addDashesToOption, "--")
-                    .AppendFormat("{0}", specification.LongName)
-                    .AppendFormatWhen(specification.MetaValue.Length > 0, "={0}", specification.MetaValue);
-            }
-            return optionName.ToString();
+            return
+                new StringBuilder(maxLength)
+                    .MapIf(
+                        specification.ShortName.Length > 0,
+                        it => it
+                            .AppendWhen(addDashesToOption, '-')
+                            .AppendFormat("{0}", specification.ShortName)
+                            .AppendFormatWhen(specification.MetaValue.Length > 0, " {0}", specification.MetaValue)
+                            .AppendWhen(specification.LongName.Length > 0, ", "))
+                    .MapIf(
+                        specification.LongName.Length > 0,
+                        it => it
+                            .AppendWhen(addDashesToOption, "--")
+                            .AppendFormat("{0}", specification.LongName)
+                            .AppendFormatWhen(specification.MetaValue.Length > 0, "={0}", specification.MetaValue))
+                    .ToString();
         }
 
         private string AddValueName(int maxLength, ValueSpecification specification)
diff --git a/src/CommandLine/Text/StringBuilderExtensions.cs b/src/CommandLine/Text/StringBuilderExtensions.cs
index 88a2886..733c004 100644
--- a/src/CommandLine/Text/StringBuilderExtensions.cs
+++ b/src/CommandLine/Text/StringBuilderExtensions.cs
@@ -41,6 +41,12 @@ namespace CommandLine.Text
             return condition ? ifTrue(builder) : ifFalse(builder);
         }
 
+        public static StringBuilder MapIf(this StringBuilder builder, bool condition,
+            Func<StringBuilder, StringBuilder> ifTrue)
+        {
+            return condition ? ifTrue(builder) : builder;
+        }
+
         public static StringBuilder AppendIfNotEmpty(this StringBuilder builder, params string[] values)
         {
             foreach (var value in values)

ATOMIC:	YES


PROJECT:	Humanizer
SHA:	2310376167c1de14862f414b2376a40ded152772
DIFF:
commit 2310376167c1de14862f414b2376a40ded152772
Author: Glenn F. Henriksen <glenn@henriksen.no>
Date:   Wed Apr 9 10:48:53 2014 +0200

    Fixed ett/et gramatical error in nb-NO resource file
    
    When counting "one",  "ett" should be used instead of "et"

diff --git a/src/Humanizer.Tests/Localisation/nb-NO/DateHumanizeTests.cs b/src/Humanizer.Tests/Localisation/nb-NO/DateHumanizeTests.cs
index b8ac85b..bc9d326 100644
--- a/src/Humanizer.Tests/Localisation/nb-NO/DateHumanizeTests.cs
+++ b/src/Humanizer.Tests/Localisation/nb-NO/DateHumanizeTests.cs
@@ -34,7 +34,7 @@ public void HoursAgo(int hours, string expected)
         [InlineData(-10, "10 minutter siden")]
         [InlineData(-3, "3 minutter siden")]
         [InlineData(-2, "2 minutter siden")]
-        [InlineData(-1, "et minutt siden")]
+        [InlineData(-1, "ett minutt siden")]
         public void MinutesAgo(int minutes, string expected)
         {
             DateHumanize.Verify(expected, minutes, TimeUnit.Minute, Tense.Past);
@@ -54,7 +54,7 @@ public void MonthsAgo(int months, string expected)
         [InlineData(-10, "10 sekunder siden")]
         [InlineData(-3, "3 sekunder siden")]
         [InlineData(-2, "2 sekunder siden")]
-        [InlineData(-1, "et sekund siden")]
+        [InlineData(-1, "ett sekund siden")]
         public void SecondsAgo(int seconds, string expected)
         {
             DateHumanize.Verify(expected, seconds, TimeUnit.Second, Tense.Past);
@@ -64,7 +64,7 @@ public void SecondsAgo(int seconds, string expected)
         [InlineData(-10, "10 år siden")]
         [InlineData(-3, "3 år siden")]
         [InlineData(-2, "2 år siden")]
-        [InlineData(-1, "et år siden")]
+        [InlineData(-1, "ett år siden")]
         public void YearsAgo(int years, string expected)
         {
             DateHumanize.Verify(expected, years, TimeUnit.Year, Tense.Past);
diff --git a/src/Humanizer/Properties/Resources.nb-NO.resx b/src/Humanizer/Properties/Resources.nb-NO.resx
index c2a7b8c..992bd54 100644
--- a/src/Humanizer/Properties/Resources.nb-NO.resx
+++ b/src/Humanizer/Properties/Resources.nb-NO.resx
@@ -118,13 +118,13 @@
     <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
   <data name="DateHumanize_SingleSecondAgo" xml:space="preserve">
-    <value>et sekund siden</value>
+    <value>ett sekund siden</value>
   </data>
   <data name="DateHumanize_MultipleSecondsAgo" xml:space="preserve">
     <value>{0} sekunder siden</value>
   </data>
   <data name="DateHumanize_SingleMinuteAgo" xml:space="preserve">
-    <value>et minutt siden</value>
+    <value>ett minutt siden</value>
   </data>
   <data name="DateHumanize_MultipleMinutesAgo" xml:space="preserve">
     <value>{0} minutter siden</value>
@@ -148,7 +148,7 @@
     <value>{0} måneder siden</value>
   </data>
   <data name="DateHumanize_SingleYearAgo" xml:space="preserve">
-    <value>et år siden</value>
+    <value>ett år siden</value>
   </data>
   <data name="DateHumanize_MultipleYearsAgo" xml:space="preserve">
     <value>{0} år siden</value>

ATOMIC:	YES


PROJECT:	Nancy
SHA:	c6a575191c80569af0eb2af2dceacf2126fcf87a
DIFF:
commit c6a575191c80569af0eb2af2dceacf2126fcf87a
Author: Andreas Håkansson <andreas@thecodejunkie.com>
Date:   Fri Aug 21 16:51:54 2015 +0200

    Added support to control the use of IApplicationStartup and IRequestStartup implementations from Browser based tests

diff --git a/src/Nancy.Testing.Tests/BrowserFixture.cs b/src/Nancy.Testing.Tests/BrowserFixture.cs
index e3298edf..872ca3ab 100644
--- a/src/Nancy.Testing.Tests/BrowserFixture.cs
+++ b/src/Nancy.Testing.Tests/BrowserFixture.cs
@@ -6,7 +6,6 @@ namespace Nancy.Testing.Tests
     using System.Security.Cryptography.X509Certificates;
     using System.Text;
     using System.Linq;
-
     using Nancy.Extensions;
     using Nancy.Tests;
     using Nancy.Helpers;
@@ -14,6 +13,7 @@ namespace Nancy.Testing.Tests
     using Xunit;
     using FakeItEasy;
     using Nancy.Authentication.Forms;
+    using Nancy.Bootstrapper;
 
     public class BrowserFixture
     {
@@ -26,7 +26,7 @@ namespace Nancy.Testing.Tests
 
             CookieBasedSessions.Enable(bootstrapper);
 
-            browser = new Browser(bootstrapper);
+            this.browser = new Browser(bootstrapper);
         }
 
         [Fact]
@@ -538,7 +538,7 @@ namespace Nancy.Testing.Tests
 
             // Then
             header.ShouldEqual(expectedHeaderValue);
-        }
+        }     
 
         public class EchoModel
         {
diff --git a/src/Nancy.Testing/ConfigurableBootstrapper.cs b/src/Nancy.Testing/ConfigurableBootstrapper.cs
index 1edf9862..6befe01e 100644
--- a/src/Nancy.Testing/ConfigurableBootstrapper.cs
+++ b/src/Nancy.Testing/ConfigurableBootstrapper.cs
@@ -45,7 +45,8 @@ namespace Nancy.Testing
 
         private bool allDiscoveredModules;
         private bool autoRegistrations = true;
-
+        private bool disableAutoApplicationStartupRegistration;
+        private bool disableAutoRequestStartupRegistration;
 
         /// <summary>
         /// Initializes a new instance of the <see cref="ConfigurableBootstrapper"/> class.
@@ -91,6 +92,12 @@ namespace Nancy.Testing
             LoadReferencesForAssemblyUnderTest(testAssemblyName);
         }
 
+        /// <summary>
+        /// Initialise the bootstrapper - can be used for adding pre/post hooks and
+        /// any other initialisation tasks that aren't specifically container setup
+        /// related
+        /// </summary>
+        /// <param name="container">Container instance for resolving types if required.</param>
         protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines)
         {
             base.ApplicationStartup(container, pipelines);
@@ -100,6 +107,14 @@ namespace Nancy.Testing
             }
         }
 
+        /// <summary>
+        /// Initialise the request - can be used for adding pre/post hooks and
+        /// any other per-request initialisation tasks that aren't specifically container setup
+        /// related
+        /// </summary>
+        /// <param name="container">Container</param>
+        /// <param name="pipelines">Current pipelines</param>
+        /// <param name="context">Current context</param>
         protected override void RequestStartup(TinyIoCContainer container, IPipelines pipelines, NancyContext context)
         {
             base.RequestStartup(container, pipelines, context);
@@ -187,7 +202,7 @@ namespace Nancy.Testing
 
         private static string GetSafePathExtension(string name)
         {
-            return Path.GetExtension(name) ?? String.Empty;
+            return Path.GetExtension(name) ?? string.Empty;
         }
 
         private IEnumerable<Type> Resolve<T>()
@@ -281,7 +296,39 @@ namespace Nancy.Testing
         /// </summary>
         protected override IEnumerable<Type> ApplicationStartupTasks
         {
-            get { return this.Resolve<IApplicationStartup>() ?? base.ApplicationStartupTasks; }
+            get
+            {
+                var tasks = base.ApplicationStartupTasks;
+
+                var user = (this.Resolve<IApplicationStartup>() ?? Enumerable.Empty<Type>()).ToArray();
+
+                if (this.disableAutoApplicationStartupRegistration || user.Any())
+                {
+                    tasks = tasks.Where(x => x.Assembly.GetName().Name.StartsWith("Nancy", StringComparison.OrdinalIgnoreCase));
+                }
+
+                return tasks.Union(user);
+            }
+        }
+
+        /// <summary>
+        /// Gets all request startup tasks
+        /// </summary>
+        protected override IEnumerable<Type> RequestStartupTasks
+        {
+            get
+            {
+                var tasks = base.RequestStartupTasks;
+
+                var user = (this.Resolve<IRequestStartup>() ?? Enumerable.Empty<Type>()).ToArray();
+
+                if (this.disableAutoRequestStartupRegistration || user.Any())
+                {
+                    tasks = tasks.Where(x => x.Assembly.GetName().Name.StartsWith("Nancy", StringComparison.OrdinalIgnoreCase));
+                }
+
+                return tasks.Union(user);
+            }
         }
 
         protected override DiagnosticsConfiguration DiagnosticsConfiguration
@@ -1791,18 +1838,114 @@ namespace Nancy.Testing
                 return this;
             }
 
+            /// <summary>
+            /// Configures the bootstrapper to use the provided instance of <see cref="IApplicationStartup"/>.
+            /// </summary>
+            /// <typeparam name="T">The type of the <see cref="IApplicationStartup"/> that the bootstrapper should use.</typeparam>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator ApplicationStartupTask<T>() where T : IApplicationStartup
+            {
+                this.bootstrapper.registeredTypes.Add(
+                    new TypeRegistration(typeof(IApplicationStartup), typeof(T)));
+
+                return this;
+            }
+
+            /// <summary>
+            /// Configures the bootstrapper to use the provided <see cref="IApplicationStartup"/> types.
+            /// </summary>
+            /// <param name="applicationStartupTypes">The <see cref="IApplicationStartup"/> types that should be used by the bootstrapper.</param>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator ApplicationStartupTasks(params Type[] applicationStartupTypes)
+            {
+                foreach (var type in applicationStartupTypes)
+                {
+                    this.bootstrapper.registeredTypes.Add(
+                        new TypeRegistration(typeof(IApplicationStartup), type));
+                }
+
+                return this;
+            }
+
+            /// <summary>
+            /// Configures the bootstrapper to use the provided instance of <see cref="IRequestStartup"/>.
+            /// </summary>
+            /// <typeparam name="T">The type of the <see cref="IApplicationStartup"/> that the bootstrapper should use.</typeparam>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator RequestStartupTask<T>() where T : IRequestStartup
+            {
+                this.bootstrapper.registeredTypes.Add(
+                    new TypeRegistration(typeof(IRequestStartup), typeof(T)));
+
+                return this;
+            }
+
+            /// <summary>
+            /// Configures the bootstrapper to use the provided <see cref="IRequestStartup"/> types.
+            /// </summary>
+            /// <param name="requestStartupTypes">The <see cref="IRequestStartup"/> types that should be used by the bootstrapper.</param>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator RequestStartupTasks(params Type[] requestStartupTypes)
+            {
+                foreach (var type in requestStartupTypes)
+                {
+                    this.bootstrapper.registeredTypes.Add(
+                        new TypeRegistration(typeof(IRequestStartup), type));
+                }
+
+                return this;
+            }
+
+            /// <summary>
+            /// Disables automatic registration of user-defined <see cref="IApplicationStartup"/> instances. It
+            /// will not prevent auto-registration of implementations bundled with Nancy.
+            /// </summary>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator DisableAutoApplicationStartupRegistration()
+            {
+                this.bootstrapper.disableAutoApplicationStartupRegistration = true;
+                return this;
+            }
+
+            /// <summary>
+            /// Disables automatic registration of user-defined <see cref="IRequestStartup"/> instances. It
+            /// will not prevent auto-registration of implementations bundled with Nancy.
+            /// </summary>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
+            public ConfigurableBootstrapperConfigurator DisableAutoRequestStartupRegistration()
+            {
+                this.bootstrapper.disableAutoRequestStartupRegistration = true;
+                return this;
+            }
+
+            /// <summary>
+            /// Adds a hook to the application startup pipeline. This can be called multiple times to add
+            /// more hooks.
+            /// </summary>
+            /// <param name="action">The pipeline hook.</param>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
             public ConfigurableBootstrapperConfigurator ApplicationStartup(Action<TinyIoCContainer, IPipelines> action)
             {
                 this.bootstrapper.applicationStartupActions.Add(action);
                 return this;
             }
 
+            /// <summary>
+            /// Adds a hook to the request startup pipeline. This can be called multiple times to add
+            /// more hooks.
+            /// </summary>
+            /// <param name="action">The pipeline hook.</param>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
             public ConfigurableBootstrapperConfigurator RequestStartup(Action<TinyIoCContainer, IPipelines, NancyContext> action)
             {
                 this.bootstrapper.requestStartupActions.Add(action);
                 return this;
             }
 
+            /// <summary>
+            /// Disables registrations performed by <see cref="IRegistrations"/> instances.
+            /// </summary>
+            /// <returns>A reference to the current <see cref="ConfigurableBootstrapperConfigurator"/>.</returns>
             public ConfigurableBootstrapperConfigurator DisableAutoRegistrations()
             {
                 this.bootstrapper.autoRegistrations = false;

ATOMIC:	YES


PROJECT:	Humanizer
SHA:	4df0f60c7c5828e9b9fefd5dc5f7a9d5d02c04a4
DIFF:
commit 4df0f60c7c5828e9b9fefd5dc5f7a9d5d02c04a4
Author: Max Malook <community@malook.de>
Date:   Mon Sep 1 23:01:56 2014 +0200

    handle Display attribute specially

diff --git a/readme.md b/readme.md
index ff4bceb..3ccb9de 100644
--- a/readme.md
+++ b/readme.md
@@ -206,6 +206,22 @@ You can even configure the name of the property of attibute to use as descriptio
 
 `Configurator.EnumDescriptionPropertyLocator = p => p.Name == "Info"`
 
+How ever prior possibilities do not provide a way to localize the descriptions, if you need this, please use `DisplayAttribute` data annotation, which is build to support localization and is utilized for this use case.
+
+```C#
+public enum EnumUnderTest
+{
+    [Display(Description = "EnumUnderTest_Member", ResourceType = typeof(Project.Resources))]
+    Member
+}
+```
+
+You will get:
+
+```C#
+EnumUnderTest.Member.Humanize() => "content" // from Project.Resources found under "EnumUnderTest_Member" resource key
+```
+
 Hopefully this will help avoid littering enums with unnecessary attributes!
 
 ###<a id="dehumanize-enums">Dehumanize Enums</a>
diff --git a/src/Humanizer.Tests/DehumanizeToEnumTests.cs b/src/Humanizer.Tests/DehumanizeToEnumTests.cs
index 5faaa7d..c6d1326 100644
--- a/src/Humanizer.Tests/DehumanizeToEnumTests.cs
+++ b/src/Humanizer.Tests/DehumanizeToEnumTests.cs
@@ -72,6 +72,20 @@ public void AllCapitalMembersAreReturnedAsIs()
             Assert.Equal(EnumUnderTest.ALLCAPITALS, EnumUnderTest.ALLCAPITALS.ToString().DehumanizeTo(typeof(EnumUnderTest)));
         }
 
+        [Fact]
+        public void HonorsDisplayAttribute()
+        {
+            Assert.Equal(EnumUnderTest.MemberWithDisplayAttribute, EnumTestsResources.MemberWithDisplayAttribute.DehumanizeTo<EnumUnderTest>());
+            Assert.Equal(EnumUnderTest.MemberWithDisplayAttribute, EnumTestsResources.MemberWithDisplayAttribute.DehumanizeTo(typeof(EnumUnderTest)));
+        }
+
+        [Fact]
+        public void HonorsLocalizedDisplayAttribute()
+        {
+            Assert.Equal(EnumUnderTest.MemberWithLocalizedDisplayAttribute, EnumTestsResources.MemberWithLocalizedDisplayAttribute.DehumanizeTo<EnumUnderTest>());
+            Assert.Equal(EnumUnderTest.MemberWithLocalizedDisplayAttribute, EnumTestsResources.MemberWithLocalizedDisplayAttribute.DehumanizeTo(typeof(EnumUnderTest)));
+        }
+
         struct DummyStructWithEnumInterfaces : IComparable, IFormattable, IConvertible
         {
             public int CompareTo(object obj)
diff --git a/src/Humanizer.Tests/EnumHumanizeTests.cs b/src/Humanizer.Tests/EnumHumanizeTests.cs
index c47d7c4..c6554ce 100644
--- a/src/Humanizer.Tests/EnumHumanizeTests.cs
+++ b/src/Humanizer.Tests/EnumHumanizeTests.cs
@@ -55,5 +55,17 @@ public void AllCapitalMembersAreReturnedAsIs()
         {
             Assert.Equal(EnumUnderTest.ALLCAPITALS.ToString(), EnumUnderTest.ALLCAPITALS.Humanize());
         }
+
+        [Fact]
+        public void HonorsDisplayAttribute()
+        {
+            Assert.Equal(EnumTestsResources.MemberWithDisplayAttribute, EnumUnderTest.MemberWithDisplayAttribute.Humanize());
+        }
+
+        [Fact]
+        public void HonorsLocalizedDisplayAttribute()
+        {
+            Assert.Equal(EnumTestsResources.MemberWithLocalizedDisplayAttribute, EnumUnderTest.MemberWithLocalizedDisplayAttribute.Humanize());
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Humanizer.Tests/EnumUnderTest.cs b/src/Humanizer.Tests/EnumUnderTest.cs
index 8f94238..cdc5f8f 100644
--- a/src/Humanizer.Tests/EnumUnderTest.cs
+++ b/src/Humanizer.Tests/EnumUnderTest.cs
@@ -1,5 +1,6 @@
 ﻿using System;
 using System.ComponentModel;
+using System.ComponentModel.DataAnnotations;
 
 namespace Humanizer.Tests
 {
@@ -16,7 +17,11 @@ public enum EnumUnderTest
         [CustomProperty(EnumTestsResources.MemberWithCustomPropertyAttribute)]
         MemberWithCustomPropertyAttribute,
         MemberWithoutDescriptionAttribute,
-        ALLCAPITALS
+        ALLCAPITALS,
+        [Display(Description = EnumTestsResources.MemberWithDisplayAttribute)]
+        MemberWithDisplayAttribute,
+        [Display(Description = "MemberWithLocalizedDisplayAttribute", ResourceType = typeof(EnumTestsResources))]
+        MemberWithLocalizedDisplayAttribute
     }
 
     public class EnumTestsResources
@@ -29,6 +34,8 @@ public class EnumTestsResources
         public const string MemberWithoutDescriptionAttributeSentence = "Member without description attribute";
         public const string MemberWithoutDescriptionAttributeTitle = "Member Without Description Attribute";
         public const string MemberWithoutDescriptionAttributeLowerCase = "member without description attribute";
+        public const string MemberWithDisplayAttribute = "Description from Display attribute";
+        public static string MemberWithLocalizedDisplayAttribute { get { return "Localized description from Display attribute"; } }
     }
 
     public class ImposterDescriptionAttribute : Attribute
diff --git a/src/Humanizer.Tests/Humanizer.Tests.csproj b/src/Humanizer.Tests/Humanizer.Tests.csproj
index 2d6937c..dbfb88d 100644
--- a/src/Humanizer.Tests/Humanizer.Tests.csproj
+++ b/src/Humanizer.Tests/Humanizer.Tests.csproj
@@ -43,6 +43,7 @@
       <HintPath>..\packages\ApprovalUtilities.3.0.5\lib\net35\ApprovalUtilities.dll</HintPath>
     </Reference>
     <Reference Include="System" />
+    <Reference Include="System.ComponentModel.DataAnnotations" />
     <Reference Include="System.Core" />
     <Reference Include="System.Xml.Linq" />
     <Reference Include="System.Data.DataSetExtensions" />
diff --git a/src/Humanizer/EnumHumanizeExtensions.cs b/src/Humanizer/EnumHumanizeExtensions.cs
index f7cb3d5..b4f3ae7 100644
--- a/src/Humanizer/EnumHumanizeExtensions.cs
+++ b/src/Humanizer/EnumHumanizeExtensions.cs
@@ -10,6 +10,9 @@ namespace Humanizer
     /// </summary>
     public static class EnumHumanizeExtensions
     {
+        private const string DisplayAttributeTypeName = "System.ComponentModel.DataAnnotations.DisplayAttribute";
+        private const string DisplayAttributeGetDescriptionMethodName = "GetDescription";
+
         private static readonly Func<PropertyInfo, bool> StringTypedProperty = p => p.PropertyType == typeof(string);
 
         /// <summary>
@@ -42,6 +45,12 @@ private static string GetCustomDescription(MemberInfo memberInfo)
             foreach (var attr in attrs)
             {
                 var attrType = attr.GetType();
+                if (attrType.FullName == DisplayAttributeTypeName)
+                {
+                    var method = attrType.GetMethod(DisplayAttributeGetDescriptionMethodName);
+                    if (method != null)
+                        return method.Invoke(attr, new object[0]).ToString();
+                }
                 var descriptionProperty =
                     attrType.GetProperties()
                         .Where(StringTypedProperty)

ATOMIC:	YES


PROJECT:	Humanizer
SHA:	aacdb635031986c7716e0b8e66b93ad6a85fd6b6
DIFF:
commit aacdb635031986c7716e0b8e66b93ad6a85fd6b6
Author: Oren Novotny <oren@novotny.org>
Date:   Mon Jun 6 20:51:46 2016 -0400

    update to later refgen for netstandard support

diff --git a/NuSpecs/Humanizer.Core.nuspec b/NuSpecs/Humanizer.Core.nuspec
index 1dab707..c0e78ef 100644
--- a/NuSpecs/Humanizer.Core.nuspec
+++ b/NuSpecs/Humanizer.Core.nuspec
@@ -14,21 +14,18 @@
     <licenseUrl>https://raw.githubusercontent.com/Humanizr/Humanizer/master/LICENSE</licenseUrl>
     <language>en</language>
     <dependencies>
-      <group targetFramework="dotnet">
-        <dependency id="System.Collections" version="4.0.0" />
-        <dependency id="System.Diagnostics.Debug" version="4.0.0" />
-        <dependency id="System.Globalization" version="4.0.0" />
-        <dependency id="System.Linq" version="4.0.0" />
-        <dependency id="System.Reflection" version="4.0.0" />
-        <dependency id="System.Reflection.Extensions" version="4.0.0" />
-        <dependency id="System.Resources.ResourceManager" version="4.0.0" />
-        <dependency id="System.Runtime" version="4.0.0" />
-        <dependency id="System.Runtime.Extensions" version="4.0.0" />
-        <dependency id="System.Text.RegularExpressions" version="4.0.0" />
+      <group targetFramework="netstandard1.0">
+        <dependency id="System.Collections" version="4.0.11-rc2-24027" />
+        <dependency id="System.Diagnostics.Debug" version="4.0.11-rc2-24027" />
+        <dependency id="System.Globalization" version="4.0.11-rc2-24027" />
+        <dependency id="System.Linq" version="4.1.0-rc2-24027" />
+        <dependency id="System.Reflection" version="4.1.0-rc2-24027" />
+        <dependency id="System.Reflection.Extensions" version="4.0.1-rc2-24027" />
+        <dependency id="System.Resources.ResourceManager" version="4.0.1-rc2-24027" />
+        <dependency id="System.Runtime" version="4.1.0-rc2-24027" />
+        <dependency id="System.Runtime.Extensions" version="4.1.0-rc2-24027" />
+        <dependency id="System.Text.RegularExpressions" version="4.0.12-rc2-24027" />
       </group>
-      <group targetFramework="xamarin.ios" />
-      <group targetFramework="monotouch" />
-      <group targetFramework="monoandroid" />
     </dependencies>
   </metadata>
   <files>
diff --git a/src/Humanizer/project.json b/src/Humanizer/project.json
index e97f346..1aa84f8 100644
--- a/src/Humanizer/project.json
+++ b/src/Humanizer/project.json
@@ -1,7 +1,7 @@
 ﻿{
   "dependencies": {
     "NETStandard.Library": "1.5.0-rc2-24027",
-    "NuSpec.ReferenceGenerator": "1.4.2"
+    "NuSpec.ReferenceGenerator": "2.0.0-beta-bld02"
   },
   "frameworks": {
     "netstandard1.0": {}

ATOMIC:	YES


PROJECT:	Hangfire
SHA:	b2c9805a4cea68135228fbe69f16e3e3b3227c72
DIFF:
commit b2c9805a4cea68135228fbe69f16e3e3b3227c72
Author: Sergey Odinokov <odinserj@gmail.com>
Date:   Thu Mar 20 22:20:51 2014 +0400

    Scheduled and queues pages fix

diff --git a/src/HangFire.Core/Storage/Monitoring/ScheduleDto.cs b/src/HangFire.Core/Storage/Monitoring/ScheduleDto.cs
index 2e53e763..da9cf37d 100644
--- a/src/HangFire.Core/Storage/Monitoring/ScheduleDto.cs
+++ b/src/HangFire.Core/Storage/Monitoring/ScheduleDto.cs
@@ -11,7 +11,7 @@ public ScheduleDto()
         }
 
         public MethodData MethodData { get; set; }
-        public DateTime ScheduledAt { get; set; }
+        public DateTime EnqueueAt { get; set; }
         public bool InScheduledState { get; set; }
     }
 }
\ No newline at end of file
diff --git a/src/HangFire.Redis/RedisMonitoringApi.cs b/src/HangFire.Redis/RedisMonitoringApi.cs
index c631cb62..b4048d07 100644
--- a/src/HangFire.Redis/RedisMonitoringApi.cs
+++ b/src/HangFire.Redis/RedisMonitoringApi.cs
@@ -128,7 +128,7 @@ public JobList<ScheduleDto> ScheduledJobs(int from, int count)
                     job.Key,
                     new ScheduleDto
                     {
-                        ScheduledAt = JobHelper.FromTimestamp((long) job.Value),
+                        EnqueueAt = JobHelper.FromTimestamp((long) job.Value),
                         MethodData = TryToGetMethod(jobs[job.Key][0], jobs[job.Key][1], jobs[job.Key][2]),
                         InScheduledState =
                             ScheduledState.StateName.Equals(states[job.Key], StringComparison.OrdinalIgnoreCase)
diff --git a/src/HangFire.SqlServer/SqlServerMonitoringApi.cs b/src/HangFire.SqlServer/SqlServerMonitoringApi.cs
index 0a494180..32169d9c 100644
--- a/src/HangFire.SqlServer/SqlServerMonitoringApi.cs
+++ b/src/HangFire.SqlServer/SqlServerMonitoringApi.cs
@@ -154,7 +154,7 @@ public JobList<ScheduleDto> ScheduledJobs(int @from, int count)
                 (job, method, stateData) => new ScheduleDto
                 {
                     MethodData = method,
-                    ScheduledAt = JobHelper.FromStringTimestamp(stateData["ScheduledAt"])
+                    EnqueueAt = JobHelper.FromStringTimestamp(stateData["EnqueueAt"])
                 });
         }
 
diff --git a/src/HangFire.Web/Pages/QueuesPage.cshtml b/src/HangFire.Web/Pages/QueuesPage.cshtml
index 7b853165..e4744b90 100644
--- a/src/HangFire.Web/Pages/QueuesPage.cshtml
+++ b/src/HangFire.Web/Pages/QueuesPage.cshtml
@@ -20,7 +20,7 @@
 @if (queues.Count == 0)
 {
     <div class="alert alert-warning">
-        You have no queues yet. Try to enqueue your first job.
+        No queued jobs found. Try to enqueue a job.
     </div>
 }
 else
diff --git a/src/HangFire.Web/Pages/QueuesPage.generated.cs b/src/HangFire.Web/Pages/QueuesPage.generated.cs
index b4fc4a2a..de2e2689 100644
--- a/src/HangFire.Web/Pages/QueuesPage.generated.cs
+++ b/src/HangFire.Web/Pages/QueuesPage.generated.cs
@@ -96,8 +96,8 @@ public override void Execute()
             
             #line default
             #line hidden
-WriteLiteral("    <div class=\"alert alert-warning\">\r\n        You have no queues yet. Try to enq" +
-"ueue your first job.\r\n    </div>\r\n");
+WriteLiteral("    <div class=\"alert alert-warning\">\r\n        No queued jobs found. Try to enque" +
+"ue a job.\r\n    </div>\r\n");
 
 
             
diff --git a/src/HangFire.Web/Pages/ScheduledJobsPage.cshtml b/src/HangFire.Web/Pages/ScheduledJobsPage.cshtml
index 66579e7c..b1b2d210 100644
--- a/src/HangFire.Web/Pages/ScheduledJobsPage.cshtml
+++ b/src/HangFire.Web/Pages/ScheduledJobsPage.cshtml
@@ -57,7 +57,7 @@ else
                         <span title="Job's state has been changed while fetching data." class="glyphicon glyphicon-question-sign"></span>
                     }
                 </td>
-                <td data-moment="@JobHelper.ToStringTimestamp(job.Value.ScheduledAt)">@job.Value.ScheduledAt</td>
+                <td data-moment="@JobHelper.ToStringTimestamp(job.Value.EnqueueAt)">@job.Value.EnqueueAt</td>
                 <td>
                     <span title="@HtmlHelper.DisplayMethodHint(job.Value.MethodData)">
                         @HtmlHelper.DisplayMethod(job.Value.MethodData)
diff --git a/src/HangFire.Web/Pages/ScheduledJobsPage.generated.cs b/src/HangFire.Web/Pages/ScheduledJobsPage.generated.cs
index 5c6a5567..67b64fda 100644
--- a/src/HangFire.Web/Pages/ScheduledJobsPage.generated.cs
+++ b/src/HangFire.Web/Pages/ScheduledJobsPage.generated.cs
@@ -193,7 +193,7 @@ public override void Execute()
 
             
             #line 60 "..\..\Pages\ScheduledJobsPage.cshtml"
-                            Write(JobHelper.ToStringTimestamp(job.Value.ScheduledAt));
+                            Write(JobHelper.ToStringTimestamp(job.Value.EnqueueAt));
 
             
             #line default
@@ -203,7 +203,7 @@ public override void Execute()
 
             
             #line 60 "..\..\Pages\ScheduledJobsPage.cshtml"
-                                                                                 Write(job.Value.ScheduledAt);
+                                                                                 Write(job.Value.EnqueueAt);
 
             
             #line default

ATOMIC:	YES


PROJECT:	Nancy
SHA:	2630d7265b43bd904eae591117d751a303ce2938
DIFF:
commit 2630d7265b43bd904eae591117d751a303ce2938
Author: Steven Robbins <ste.robbins@gmail.com>
Date:   Thu Mar 24 22:21:20 2011 +0000

    Refactor - currently form body not working

diff --git a/src/Nancy.Demo.Authentication.Forms.TestingDemo/LoginFixture.cs b/src/Nancy.Demo.Authentication.Forms.TestingDemo/LoginFixture.cs
index ba4aa2fe..5bc58c9f 100644
--- a/src/Nancy.Demo.Authentication.Forms.TestingDemo/LoginFixture.cs
+++ b/src/Nancy.Demo.Authentication.Forms.TestingDemo/LoginFixture.cs
@@ -20,35 +20,30 @@ namespace Nancy.Demo.Authentication.Forms.TestingDemo
         [Fact]
         public void Should_redirect_to_login_with_error_querystring_if_username_or_password_incorrect()
         {
-            // TODO - form encoded helper
-            var bodyBytes = Encoding.ASCII.GetBytes("Username=username&Password=wrongpassword");
-            var requestBodyStream = new MemoryStream(bodyBytes);
-
             // Given, When
-            var context = browser.Post("/login/", (with) =>
+            var response = browser.Post("/login/", (with) =>
             {
                 with.HttpRequest();
-                with.Body(requestBodyStream);
+                with.FormValue("Username", "username");
+                with.FormValue("Password", "wrongpassword");
             });
 
             // TODO - add "ShouldRedirectTo"
-            context.Response.StatusCode.ShouldEqual(HttpStatusCode.SeeOther);
-            context.Response.Headers["Location"].ShouldEqual("/login?error=true");
-
-            requestBodyStream.Dispose();
+            response.StatusCode.ShouldEqual(HttpStatusCode.SeeOther);
+            response.Headers["Location"].ShouldEqual("/login?error=true");
         }
 
         [Fact]
         public void Should_display_error_message_when_error_passed()
         {
             // Given, When
-            var context = browser.Get("/login", (with) =>
+            var response = browser.Get("/login", (with) =>
                 {
                     with.HttpRequest();
                     with.Query("error", "true");
                 });
 
-            context.DocumentBody()["#errorBox"]
+            response.Body["#errorBox"]
                 .ShouldExistOnce()
                 .And.ShouldBeOfClass("floatingError")
                 .And.ShouldContain("invalid", StringComparison.InvariantCultureIgnoreCase);
diff --git a/src/Nancy.Testing/Browser.cs b/src/Nancy.Testing/Browser.cs
index a6ddd438..33fad320 100644
--- a/src/Nancy.Testing/Browser.cs
+++ b/src/Nancy.Testing/Browser.cs
@@ -1,6 +1,8 @@
 namespace Nancy.Testing
 {
     using System;
+    using System.IO;
+    using System.Text;
     using Bootstrapper;
     using IO;
 
@@ -28,8 +30,8 @@ namespace Nancy.Testing
         /// </summary>
         /// <param name="path">The path that is being requested.</param>
         /// <param name="browserContext">An closure for providing browser context for the request.</param>
-        /// <returns>An <see cref="NancyContext"/> instance of the executed request.</returns>
-        public NancyContext Delete(string path, Action<BrowserContext> browserContext)
+        /// <returns>An <see cref="BrowserResponse"/> instance of the executed request.</returns>
+        public BrowserResponse Delete(string path, Action<BrowserContext> browserContext)
         {
             return this.HandleRequest("DELETE", path, browserContext);
         }
@@ -39,8 +41,8 @@ namespace Nancy.Testing
         /// </summary>
         /// <param name="path">The path that is being requested.</param>
         /// <param name="browserContext">An closure for providing browser context for the request.</param>
-        /// <returns>An <see cref="NancyContext"/> instance of the executed request.</returns>
-        public NancyContext Get(string path, Action<BrowserContext> browserContext)
+        /// <returns>An <see cref="BrowserResponse"/> instance of the executed request.</returns>
+        public BrowserResponse Get(string path, Action<BrowserContext> browserContext)
         {
             return this.HandleRequest("GET", path, browserContext);
         }
@@ -50,8 +52,8 @@ namespace Nancy.Testing
         /// </summary>
         /// <param name="path">The path that is being requested.</param>
         /// <param name="browserContext">An closure for providing browser context for the request.</param>
-        /// <returns>An <see cref="NancyContext"/> instance of the executed request.</returns>
-        public NancyContext Post(string path, Action<BrowserContext> browserContext)
+        /// <returns>An <see cref="BrowserResponse"/> instance of the executed request.</returns>
+        public BrowserResponse Post(string path, Action<BrowserContext> browserContext)
         {
             return this.HandleRequest("POST", path, browserContext);
         }
@@ -61,18 +63,18 @@ namespace Nancy.Testing
         /// </summary>
         /// <param name="path">The path that is being requested.</param>
         /// <param name="browserContext">An closure for providing browser context for the request.</param>
-        /// <returns>An <see cref="NancyContext"/> instance of the executed request.</returns>
-        public NancyContext Put(string path, Action<BrowserContext> browserContext)
+        /// <returns>An <see cref="BrowserResponse"/> instance of the executed request.</returns>
+        public BrowserResponse Put(string path, Action<BrowserContext> browserContext)
         {
             return this.HandleRequest("PUT", path, browserContext);
         }
 
-        private NancyContext HandleRequest(string method, string path, Action<BrowserContext> browserContext)
+        private BrowserResponse HandleRequest(string method, string path, Action<BrowserContext> browserContext)
         {
             var request =
                 CreateRequest(method, path, browserContext);
 
-            return this.engine.HandleRequest(request);
+            return new BrowserResponse(this.engine.HandleRequest(request));
         }
 
         private static Request CreateRequest(string method, string path, Action<BrowserContext> browserContext)
@@ -85,8 +87,16 @@ namespace Nancy.Testing
             var contextValues =
                 (IBrowserContextValues)context;
 
+            var bodyContents = String.IsNullOrEmpty(contextValues.BodyString)
+                                   ? contextValues.FormValues
+                                   : contextValues.BodyString;
+
+            var bodyBytes = Encoding.UTF8.GetBytes(bodyContents);
+            var requestBodyStream = new MemoryStream(bodyBytes);
+
+            // TODO - use the new ctors when owin is merged in
             var requestStream =
-                RequestStream.FromStream(contextValues.Body);
+                RequestStream.FromStream(requestBodyStream);
 
             return new Request(method, path, contextValues.Headers, requestStream, contextValues.Protocol, contextValues.QueryString);
         }
diff --git a/src/Nancy.Testing/BrowserContext.cs b/src/Nancy.Testing/BrowserContext.cs
index e2f3dcb8..1b82b17b 100644
--- a/src/Nancy.Testing/BrowserContext.cs
+++ b/src/Nancy.Testing/BrowserContext.cs
@@ -17,6 +17,8 @@
             this.Values.Headers = new Dictionary<string, IEnumerable<string>>();
             this.Values.Protocol = "http";
             this.Values.QueryString = String.Empty;
+            this.Values.BodyString = String.Empty;
+            this.Values.FormValues = String.Empty;
         }
 
         /// <summary>
@@ -36,6 +38,16 @@
         /// </summary>
         string IBrowserContextValues.QueryString { get; set; }
 
+        /// <summary>
+        /// Gets or sets the body string
+        /// </summary>
+        string IBrowserContextValues.BodyString { get; set; }
+
+        /// <summary>
+        /// Gets or sets the form values string
+        /// </summary>
+        string IBrowserContextValues.FormValues { get; set; }
+
         /// <summary>
         /// Gets or sets the headers that should be sent with the HTTP request.
         /// </summary>
@@ -45,10 +57,10 @@
         /// <summary>
         /// Adds a body to the HTTP request.
         /// </summary>
-        /// <param name="body">A <see cref="Stream"/> that should be used as the HTTP request body.</param>
-        public void Body(Stream body)
+        /// <param name="body">A string that should be used as the HTTP request body.</param>
+        public void Body(string body)
         {
-            this.Values.Body = body;
+            this.Values.BodyString = body;
         }
 
         /// <summary>
@@ -102,6 +114,18 @@
             get { return this; }
         }
 
+        public void FormValue(string key, string value)
+        {
+            if (!String.IsNullOrEmpty(this.Values.BodyString))
+            {
+                throw new InvalidOperationException("Form value cannot be set as well as body string");
+            }
 
+            this.Values.FormValues += String.Format(
+                "{0}{1}={2}",
+                this.Values.FormValues.Length == 0 ? String.Empty : "&", 
+                key,
+                value);
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Nancy.Testing/BrowserResponse.cs b/src/Nancy.Testing/BrowserResponse.cs
new file mode 100644
index 00000000..504d55a8
--- /dev/null
+++ b/src/Nancy.Testing/BrowserResponse.cs
@@ -0,0 +1,52 @@
+﻿namespace Nancy.Testing
+{
+    using System;
+    using System.Collections.Generic;
+    using System.IO;
+
+    /// <summary>
+    /// </summary>
+    public class BrowserResponse
+    {
+        public BrowserResponse(NancyContext context)
+        {
+            if (context == null)
+            {
+                throw new ArgumentNullException("context");
+            }
+
+            this.Context = context;
+        }
+
+        public NancyContext Context { get; private set; }
+
+        public HttpStatusCode StatusCode
+        {
+            get { return this.Context.Response.StatusCode; }
+        }
+
+        public IDictionary<string, string> Headers
+        {
+            get { return this.Context.Response.Headers; }
+        }
+
+        private DocumentWrapper responseBody;
+        public DocumentWrapper Body
+        {
+            get
+            {
+                if (this.responseBody == null)
+                {
+                    using (var contentsStream = new MemoryStream())
+                    {
+                        this.Context.Response.Contents.Invoke(contentsStream);
+                        contentsStream.Position = 0;
+                        this.responseBody = new DocumentWrapper(contentsStream);
+                    }
+                }
+
+                return this.responseBody;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Nancy.Testing/IBrowserContextValues.cs b/src/Nancy.Testing/IBrowserContextValues.cs
index 66f9a1c9..d645714e 100644
--- a/src/Nancy.Testing/IBrowserContextValues.cs
+++ b/src/Nancy.Testing/IBrowserContextValues.cs
@@ -30,5 +30,15 @@
         /// Gets or sets the querystring
         /// </summary>
         string QueryString { get; set; }
+
+        /// <summary>
+        /// Gets or sets the body string
+        /// </summary>
+        string BodyString { get; set; }
+
+        /// <summary>
+        /// Gets or sets the form values string
+        /// </summary>
+        string FormValues { get; set; }
     }
 }
\ No newline at end of file

ATOMIC:	YES


PROJECT:	Lean
SHA:	8be087a7901ceeeff53c14050be698b6a41067c1
DIFF:
commit 8be087a7901ceeeff53c14050be698b6a41067c1
Author: David Hsieh <dcchsieh@gmail.com>
Date:   Thu Apr 23 02:18:17 2015 +1000

    Max and Min is now non-accessible, removed rounding off
    
    Max and Min is now non-accessible.
    
    Removed rounding off as it's become irrelevant.

diff --git a/Indicators/Stochastics.cs b/Indicators/Stochastics.cs
index 51c5efe6..c6b32a4c 100644
--- a/Indicators/Stochastics.cs
+++ b/Indicators/Stochastics.cs
@@ -13,7 +13,6 @@
  * limitations under the License.
 */
 
-using System;
 using QuantConnect.Data.Market;
 
 namespace QuantConnect.Indicators
@@ -42,13 +41,14 @@ namespace QuantConnect.Indicators
         public IndicatorBase<TradeBar> StochD { get; private set; }
 
         /// <summary>
+        /// Gets or sets the maximum of given period.
         /// </summary>
-        public IndicatorBase<IndicatorDataPoint> Maximum { get; set; }
+        private IndicatorBase<IndicatorDataPoint> Maximum { get; set; }
 
         /// <summary>
         /// Gets or sets the mininum of given period.
         /// </summary>
-        public IndicatorBase<IndicatorDataPoint> Mininum { get; set; }
+        private IndicatorBase<IndicatorDataPoint> Mininum { get; set; }
 
         /// <summary>
         /// Placeholder to calculate the sum of Fast %K.
@@ -60,11 +60,6 @@ namespace QuantConnect.Indicators
         /// </summary>
         public IndicatorBase<IndicatorDataPoint> SumSlowK { get; private set; }
 
-        /// <summary>
-        /// The rounding off
-        /// </summary>
-        private const int RoundingOff = 5;
-
         /// <summary>
         /// Creates a new Stochastics Indicator from the specified periods.
         /// </summary>
@@ -117,7 +112,7 @@ namespace QuantConnect.Indicators
             FastStoch.Update(input);
             StochK.Update(input);
             StochD.Update(input);
-            return Math.Round(StochK, 5) * 100;
+            return StochK * 100;
         }
 
         /// <summary>
@@ -125,6 +120,7 @@ namespace QuantConnect.Indicators
         /// </summary>
         /// <param name="period">The period.</param>
         /// <param name="input">The input.</param>
+        /// <returns>The Fast Stochastics %K value.</returns>
         private decimal ComputeFastStoch(int period, TradeBar input)
         {
             var fastStoch = Maximum.Samples >= period ? (input.Close - Mininum) / (Maximum - Mininum) : new decimal(0.0);
@@ -138,11 +134,12 @@ namespace QuantConnect.Indicators
         /// <param name="period">The period.</param>
         /// <param name="constantK">The constant k.</param>
         /// <param name="input">The input.</param>
+        /// <returns>The Slow Stochastics %K value.</returns>
         private decimal ComputeStochK(int period, int constantK, TradeBar input)
         {
             var stochK = Maximum.Samples >= (period + constantK - 1) ? SumFastK / constantK : new decimal(0.0);
             SumSlowK.Update(input.Time, stochK);
-            return Math.Round(stochK, RoundingOff) * 100;
+            return stochK * 100;
         }
 
         /// <summary>
@@ -151,10 +148,11 @@ namespace QuantConnect.Indicators
         /// <param name="period">The period.</param>
         /// <param name="constantK">The constant k.</param>
         /// <param name="constantD">The constant d.</param>
+        /// <returns>The Slow Stochastics %D value.</returns>
         private decimal ComputeStochD(int period, int constantK, int constantD)
         {
             var stochD = Maximum.Samples >= (period + constantK + constantD - 2) ? SumSlowK / constantD : new decimal(0.0);
-            return Math.Round(stochD, RoundingOff) * 100;
+            return stochD * 100;
         }
         /// <summary>
         /// Resets this indicator to its initial state

ATOMIC:	YES


PROJECT:	Ninject
SHA:	55f57ed9d38041474420a3aa438531bf5943b3ac
DIFF:
commit 55f57ed9d38041474420a3aa438531bf5943b3ac
Author: nkohari <nkohari@120300b3-9e3e-0410-8997-0939a4f6c7b0>
Date:   Wed Feb 11 01:01:44 2009 +0000

    git-svn-id: http://ninject.googlecode.com/svn/experiments/ninject2@135 120300b3-9e3e-0410-8997-0939a4f6c7b0

diff --git a/Ninject.build b/Ninject.build
index 17b7e33..2328882 100644
--- a/Ninject.build
+++ b/Ninject.build
@@ -247,7 +247,7 @@
 	</target>
 
 	<target name="test" depends="compile-tests" unless="${skip.tests}">
-		<xunit workingDir="${current.path.test}" assembly="Ninject.Tests.dll" html="${current.path.test}"/>
+		<xunit workingDir="${current.path.test}" assembly="Ninject.Tests.dll" html="${current.path.test}/results.html"/>
 	</target>
 
 	<target name="package" depends="all">
diff --git a/src/Ninject/Syntax/ExtensionsForIEnumerable.cs b/src/Ninject.Tests/ExtensionsForIEnumerable.cs
similarity index 85%
rename from src/Ninject/Syntax/ExtensionsForIEnumerable.cs
rename to src/Ninject.Tests/ExtensionsForIEnumerable.cs
index 6659806..d8286c2 100644
--- a/src/Ninject/Syntax/ExtensionsForIEnumerable.cs
+++ b/src/Ninject.Tests/ExtensionsForIEnumerable.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 
-namespace Ninject.Syntax
+namespace Ninject.Tests
 {
 	public static class ExtensionsForIEnumerable
 	{
diff --git a/src/Ninject.Tests/Ninject.Tests.csproj b/src/Ninject.Tests/Ninject.Tests.csproj
index 4465c41..9058f49 100644
--- a/src/Ninject.Tests/Ninject.Tests.csproj
+++ b/src/Ninject.Tests/Ninject.Tests.csproj
@@ -53,6 +53,7 @@
     </Reference>
   </ItemGroup>
   <ItemGroup>
+    <Compile Include="ExtensionsForIEnumerable.cs" />
     <Compile Include="Integration\ThreadScopeTests.cs" />
     <Compile Include="Integration\SpecialResolutionTests.cs" />
     <Compile Include="Unit\ConstructorInjectorTests.cs" />
diff --git a/src/Ninject.Web.Mvc/ControllerRegistry.cs b/src/Ninject.Web.Mvc/ControllerRegistry.cs
index f964e7a..1b33441 100644
--- a/src/Ninject.Web.Mvc/ControllerRegistry.cs
+++ b/src/Ninject.Web.Mvc/ControllerRegistry.cs
@@ -26,7 +26,8 @@ namespace Ninject.Web.Mvc
 
 		public void RegisterAllControllersIn(Assembly assembly)
 		{
-			FindControllersIn(assembly).Map(t => _controllers[t.Name] = t.Type);
+			foreach (ControllerDefinition definition in FindControllersIn(assembly))
+				_controllers[definition.Name] = definition.Type;
 		}
 
 		public void Register(string controllerName, Type controllerType)
diff --git a/src/Ninject.Web.Mvc/MvcModule.cs b/src/Ninject.Web.Mvc/MvcModule.cs
index fc2e3d8..d1b98a1 100644
--- a/src/Ninject.Web.Mvc/MvcModule.cs
+++ b/src/Ninject.Web.Mvc/MvcModule.cs
@@ -6,7 +6,6 @@ using Ninject.Modules;
 
 namespace Ninject.Web.Mvc
 {
-	[IgnoreModule]
 	public class MvcModule : Module
 	{
 		public override void Load()
diff --git a/src/Ninject/Activation/Caching/Cache.cs b/src/Ninject/Activation/Caching/Cache.cs
index d8fe6e7..4d83173 100644
--- a/src/Ninject/Activation/Caching/Cache.cs
+++ b/src/Ninject/Activation/Caching/Cache.cs
@@ -3,8 +3,8 @@ using System.Linq;
 using Ninject.Components;
 using Ninject.Infrastructure;
 using Ninject.Infrastructure.Disposal;
+using Ninject.Infrastructure.Language;
 using Ninject.Planning.Bindings;
-using Ninject.Syntax;
 
 namespace Ninject.Activation.Caching
 {
@@ -12,9 +12,8 @@ namespace Ninject.Activation.Caching
 	{
 		private readonly object _mutex = new object();
 
-		public IPipeline Pipeline { get; set; }
-		public ICachePruner Pruner { get; set; }
-
+		public IPipeline Pipeline { get; private set; }
+		public ICachePruner Pruner { get; private set; }
 		public Multimap<IBinding, CacheEntry> Entries { get; private set; }
 
 		public Cache(IPipeline pipeline, ICachePruner pruner)
diff --git a/src/Ninject/Activation/Caching/CachePruner.cs b/src/Ninject/Activation/Caching/CachePruner.cs
index 65c66b3..9197cf8 100644
--- a/src/Ninject/Activation/Caching/CachePruner.cs
+++ b/src/Ninject/Activation/Caching/CachePruner.cs
@@ -6,7 +6,7 @@ namespace Ninject.Activation.Caching
 {
 	public class CachePruner : NinjectComponent, ICachePruner
 	{
-		private static WeakReference _indicator = new WeakReference(new object());
+		private static readonly WeakReference _indicator = new WeakReference(new object());
 		private Timer _timer;
 
 		public void StartPruning(ICache cache)
diff --git a/src/Ninject/Activation/Constraints/IConstraint.cs b/src/Ninject/Activation/Constraints/IConstraint.cs
deleted file mode 100644
index 691cb37..0000000
--- a/src/Ninject/Activation/Constraints/IConstraint.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-﻿using System;
-using Ninject.Planning.Bindings;
-
-namespace Ninject.Activation.Constraints
-{
-	public interface IConstraint
-	{
-		bool Matches(IBindingMetadata metadata);
-	}
-}
\ No newline at end of file
diff --git a/src/Ninject/Activation/Constraints/PredicateConstraint.cs b/src/Ninject/Activation/Constraints/PredicateConstraint.cs
deleted file mode 100644
index da0f22f..0000000
--- a/src/Ninject/Activation/Constraints/PredicateConstraint.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿using System;
-using Ninject.Planning.Bindings;
-
-namespace Ninject.Activation.Constraints
-{
-	public class PredicateConstraint : IConstraint
-	{
-		public Func<IBindingMetadata, bool> Predicate { get; set; }
-
-		public PredicateConstraint(Func<IBindingMetadata, bool> predicate)
-		{
-			Predicate = predicate;
-		}
-
-		public bool Matches(IBindingMetadata metadata)
-		{
-			return Predicate(metadata);
-		}
-
-		public static implicit operator PredicateConstraint(Func<IBindingMetadata, bool> predicate)
-		{
-			return new PredicateConstraint(predicate);
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/Ninject/Activation/Context.cs b/src/Ninject/Activation/Context.cs
index f039d96..8480a23 100644
--- a/src/Ninject/Activation/Context.cs
+++ b/src/Ninject/Activation/Context.cs
@@ -11,8 +11,6 @@ namespace Ninject.Activation
 {
 	public class Context : TraceInfoProvider, IContext
 	{
-		public ICache Cache { get; set; }
-
 		public IKernel Kernel { get; set; }
 		public IRequest Request { get; set; }
 		public IBinding Binding { get; set; }
@@ -23,12 +21,11 @@ namespace Ninject.Activation
 		public Type[] GenericArguments { get; private set; }
 		public bool HasInferredGenericArguments { get; private set; }
 
-		public Context(IKernel kernel, IRequest request, IBinding binding, ICache cache)
+		public Context(IKernel kernel, IRequest request, IBinding binding)
 		{
 			Kernel = kernel;
 			Request = request;
 			Binding = binding;
-			Cache = cache;
 			Parameters = request.Parameters.Union(binding.Parameters).ToList();
 
 			if (binding.Service.IsGenericTypeDefinition)
@@ -47,22 +44,5 @@ namespace Ninject.Activation
 		{
 			return Binding.GetProvider(this);
 		}
-
-		public object Resolve()
-		{
-			lock (Binding)
-			{
-				Instance = Cache.TryGet(this);
-
-				if (Instance != null)
-					return Instance;
-
-				Instance = GetProvider().Create(this);
-
-				Cache.Remember(this);
-
-				return Instance;
-			}
-		}
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Activation/Hooks/ConstantHook.cs b/src/Ninject/Activation/Hooks/ConstantHook.cs
new file mode 100644
index 0000000..0891af5
--- /dev/null
+++ b/src/Ninject/Activation/Hooks/ConstantHook.cs
@@ -0,0 +1,19 @@
+﻿using System;
+
+namespace Ninject.Activation.Hooks
+{
+	public class ConstantHook : IHook
+	{
+		public object Value { get; private set; }
+
+		public ConstantHook(object value)
+		{
+			Value = value;
+		}
+
+		public object Resolve()
+		{
+			return Value;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/Ninject/Activation/Hooks/ContextResolutionHook.cs b/src/Ninject/Activation/Hooks/ContextResolutionHook.cs
new file mode 100644
index 0000000..ae14007
--- /dev/null
+++ b/src/Ninject/Activation/Hooks/ContextResolutionHook.cs
@@ -0,0 +1,33 @@
+using System;
+using Ninject.Activation.Caching;
+
+namespace Ninject.Activation.Hooks
+{
+	public class ContextResolutionHook : IHook
+	{
+		public IContext Context { get; private set; }
+		public ICache Cache { get; private set; }
+
+		public ContextResolutionHook(IContext context, ICache cache)
+		{
+			Context = context;
+			Cache = cache;
+		}
+
+		public object Resolve()
+		{
+			lock (Context.Binding)
+			{
+				Context.Instance = Cache.TryGet(Context);
+
+				if (Context.Instance != null)
+					return Context.Instance;
+
+				Context.Instance = Context.GetProvider().Create(Context);
+				Cache.Remember(Context);
+
+				return Context.Instance;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/Ninject/Activation/IHook.cs b/src/Ninject/Activation/Hooks/IHook.cs
similarity index 60%
rename from src/Ninject/Activation/IHook.cs
rename to src/Ninject/Activation/Hooks/IHook.cs
index 656f768..1fa0076 100644
--- a/src/Ninject/Activation/IHook.cs
+++ b/src/Ninject/Activation/Hooks/IHook.cs
@@ -1,6 +1,6 @@
 using System;
 
-namespace Ninject.Activation
+namespace Ninject.Activation.Hooks
 {
 	public interface IHook
 	{
diff --git a/src/Ninject/Activation/IContext.cs b/src/Ninject/Activation/IContext.cs
index 6fd7544..37e1c77 100644
--- a/src/Ninject/Activation/IContext.cs
+++ b/src/Ninject/Activation/IContext.cs
@@ -7,7 +7,7 @@ using Ninject.Planning.Bindings;
 
 namespace Ninject.Activation
 {
-	public interface IContext : IHook, IHaveTraceInfo
+	public interface IContext : IHaveTraceInfo
 	{
 		IKernel Kernel { get; }
 		IRequest Request { get; }
diff --git a/src/Ninject/Activation/IRequest.cs b/src/Ninject/Activation/IRequest.cs
index 135ca87..39e1d65 100644
--- a/src/Ninject/Activation/IRequest.cs
+++ b/src/Ninject/Activation/IRequest.cs
@@ -1,6 +1,5 @@
 using System;
 using System.Collections.Generic;
-using Ninject.Activation.Constraints;
 using Ninject.Parameters;
 using Ninject.Planning.Bindings;
 using Ninject.Planning.Targets;
@@ -13,7 +12,7 @@ namespace Ninject.Activation
 		ITarget Target { get; }
 		Type Service { get; }
 
-		ICollection<IConstraint> Constraints { get; }
+		ICollection<Func<IBindingMetadata, bool>> Constraints { get; }
 		ICollection<IParameter> Parameters { get; }
 
 		bool ConstraintsSatisfiedBy(IBinding binding);
diff --git a/src/Ninject/Activation/Pipeline.cs b/src/Ninject/Activation/Pipeline.cs
index 99c3c83..fb88bc3 100644
--- a/src/Ninject/Activation/Pipeline.cs
+++ b/src/Ninject/Activation/Pipeline.cs
@@ -3,7 +3,7 @@ using System.Collections.Generic;
 using System.Linq;
 using Ninject.Activation.Strategies;
 using Ninject.Components;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Activation
 {
diff --git a/src/Ninject/Activation/Providers/CallbackProvider.cs b/src/Ninject/Activation/Providers/CallbackProvider.cs
index 2f6b1b2..9d2f16f 100644
--- a/src/Ninject/Activation/Providers/CallbackProvider.cs
+++ b/src/Ninject/Activation/Providers/CallbackProvider.cs
@@ -4,7 +4,7 @@ namespace Ninject.Activation.Providers
 {
 	public class CallbackProvider<T> : Provider<T>
 	{
-		public Func<IContext, T> Method { get; set; }
+		public Func<IContext, T> Method { get; private set; }
 
 		public CallbackProvider(Func<IContext, T> method)
 		{
diff --git a/src/Ninject/Activation/Providers/ConstantProvider.cs b/src/Ninject/Activation/Providers/ConstantProvider.cs
index d116fb9..6ab5d92 100644
--- a/src/Ninject/Activation/Providers/ConstantProvider.cs
+++ b/src/Ninject/Activation/Providers/ConstantProvider.cs
@@ -1,11 +1,10 @@
 ﻿using System;
-using Ninject.Activation;
 
 namespace Ninject.Activation.Providers
 {
 	public class ConstantProvider<T> : Provider<T>
 	{
-		public T Value { get; set; }
+		public T Value { get; private set; }
 
 		public ConstantProvider(T value)
 		{
diff --git a/src/Ninject/Activation/Providers/StandardProvider.cs b/src/Ninject/Activation/Providers/StandardProvider.cs
index 9bb1e26..f9f1f16 100644
--- a/src/Ninject/Activation/Providers/StandardProvider.cs
+++ b/src/Ninject/Activation/Providers/StandardProvider.cs
@@ -12,9 +12,9 @@ namespace Ninject.Activation.Providers
 	{
 		public Type Type { get; private set; }
 
-		public IInjectorFactory InjectorFactory { get; set; }
-		public IPlanner Planner { get; set; }
-		public IPipeline Pipeline { get; set; }
+		public IInjectorFactory InjectorFactory { get; private set; }
+		public IPlanner Planner { get; private set; }
+		public IPipeline Pipeline { get; private set; }
 
 		public StandardProvider(Type type, IInjectorFactory injectorFactory, IPlanner planner, IPipeline pipeline)
 		{
diff --git a/src/Ninject/Activation/Request.cs b/src/Ninject/Activation/Request.cs
index 75292ac..61d2a1c 100644
--- a/src/Ninject/Activation/Request.cs
+++ b/src/Ninject/Activation/Request.cs
@@ -1,7 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
-using Ninject.Activation.Constraints;
 using Ninject.Parameters;
 using Ninject.Planning.Bindings;
 using Ninject.Planning.Targets;
@@ -14,16 +13,16 @@ namespace Ninject.Activation
 		public ITarget Target { get; set; }
 		public Type Service { get; set; }
 
-		public ICollection<IConstraint> Constraints { get; set; }
+		public ICollection<Func<IBindingMetadata, bool>> Constraints { get; set; }
 		public ICollection<IParameter> Parameters { get; set; }
 
 		public Func<object> ScopeCallback { get; set; }
 
-		public Request(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters, Func<object> scopeCallback)
+		public Request(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters, Func<object> scopeCallback)
 		{
 			Service = service;
-			Constraints = constraints.ToList();
-			Parameters = parameters.ToList();
+			Constraints = constraints == null ? new List<Func<IBindingMetadata, bool>>() : constraints.ToList();
+			Parameters = parameters == null ? new List<IParameter>() : parameters.ToList();
 			ScopeCallback = scopeCallback;
 		}
 
@@ -39,7 +38,7 @@ namespace Ninject.Activation
 
 		public bool ConstraintsSatisfiedBy(IBinding binding)
 		{
-			return Constraints.All(c => c.Matches(binding.Metadata));
+			return Constraints.All(constraint => constraint(binding.Metadata));
 		}
 
 		public object GetScope()
diff --git a/src/Ninject/Activation/Scope/ActivationScope.cs b/src/Ninject/Activation/Scope/ActivationScope.cs
index 1aae8bd..3f2bfcc 100644
--- a/src/Ninject/Activation/Scope/ActivationScope.cs
+++ b/src/Ninject/Activation/Scope/ActivationScope.cs
@@ -1,37 +1,38 @@
 ﻿using System;
 using System.Collections.Generic;
-using Ninject.Activation.Constraints;
+using Ninject.Activation.Hooks;
 using Ninject.Infrastructure.Disposal;
 using Ninject.Parameters;
+using Ninject.Planning.Bindings;
 using Ninject.Syntax;
 
 namespace Ninject.Activation.Scope
 {
 	public class ActivationScope : DisposableObject, IActivationScope
 	{
-		private readonly IResolutionRoot _parent;
+		public IResolutionRoot Parent { get; private set; }
 
 		public ActivationScope(IResolutionRoot parent)
 		{
-			_parent = parent;
+			Parent = parent;
 		}
 
 		public bool CanResolve(IRequest request)
 		{
-			return _parent.CanResolve(request);
+			return Parent.CanResolve(request);
 		}
 
-		public IEnumerable<IHook> Resolve(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters)
+		public IEnumerable<IHook> Resolve(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters)
 		{
 			return Resolve(CreateDirectRequest(service, constraints, parameters));
 		}
 
 		public IEnumerable<IHook> Resolve(IRequest request)
 		{
-			return _parent.Resolve(request);
+			return Parent.Resolve(request);
 		}
 
-		protected virtual IRequest CreateDirectRequest(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters)
+		protected virtual IRequest CreateDirectRequest(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters)
 		{
 			return new Request(service, constraints, parameters, () => this);
 		}
diff --git a/src/Ninject/Activation/Strategies/MethodInjectionStrategy.cs b/src/Ninject/Activation/Strategies/MethodInjectionStrategy.cs
index f0795a2..ed1b3b2 100644
--- a/src/Ninject/Activation/Strategies/MethodInjectionStrategy.cs
+++ b/src/Ninject/Activation/Strategies/MethodInjectionStrategy.cs
@@ -7,7 +7,7 @@ namespace Ninject.Activation.Strategies
 {
 	public class MethodInjectionStrategy : ActivationStrategy
 	{
-		public IInjectorFactory InjectorFactory { get; set; }
+		public IInjectorFactory InjectorFactory { get; private set; }
 
 		public MethodInjectionStrategy(IInjectorFactory injectorFactory)
 		{
diff --git a/src/Ninject/Activation/Strategies/PropertyInjectionStrategy.cs b/src/Ninject/Activation/Strategies/PropertyInjectionStrategy.cs
index 2a51a81..da494a1 100644
--- a/src/Ninject/Activation/Strategies/PropertyInjectionStrategy.cs
+++ b/src/Ninject/Activation/Strategies/PropertyInjectionStrategy.cs
@@ -9,7 +9,7 @@ namespace Ninject.Activation.Strategies
 {
 	public class PropertyInjectionStrategy : ActivationStrategy
 	{
-		public IInjectorFactory InjectorFactory { get; set; }
+		public IInjectorFactory InjectorFactory { get; private set; }
 
 		public PropertyInjectionStrategy(IInjectorFactory injectorFactory)
 		{
diff --git a/src/Ninject/Attributes/ConstraintAttribute.cs b/src/Ninject/Attributes/ConstraintAttribute.cs
index 13e24bb..1ad8714 100644
--- a/src/Ninject/Attributes/ConstraintAttribute.cs
+++ b/src/Ninject/Attributes/ConstraintAttribute.cs
@@ -1,12 +1,11 @@
 ﻿using System;
-using Ninject.Activation.Constraints;
 using Ninject.Planning.Bindings;
 
 namespace Ninject
 {
 	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = true, Inherited = true)]
-	public abstract class ConstraintAttribute : Attribute, IConstraint
+	public abstract class ConstraintAttribute : Attribute
 	{
-		public abstract bool Matches(IBindingMetadata metadata);
+		public abstract bool Matches(IBindingMetadata obj);
 	}
 }
diff --git a/src/Ninject/Attributes/IgnoreModule.cs b/src/Ninject/Attributes/IgnoreModule.cs
deleted file mode 100644
index 6c230e8..0000000
--- a/src/Ninject/Attributes/IgnoreModule.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿using System;
-
-namespace Ninject
-{
-	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
-	public class IgnoreModule : Attribute { }
-}
diff --git a/src/Ninject/Attributes/NamedAttribute.cs b/src/Ninject/Attributes/NamedAttribute.cs
index 3315be2..87c2c7d 100644
--- a/src/Ninject/Attributes/NamedAttribute.cs
+++ b/src/Ninject/Attributes/NamedAttribute.cs
@@ -12,9 +12,9 @@ namespace Ninject
 			Name = name;
 		}
 
-		public override bool Matches(IBindingMetadata metadata)
+		public override bool Matches(IBindingMetadata obj)
 		{
-			return metadata.Name == Name;
+			return obj.Name == Name;
 		}
 	}
 }
diff --git a/src/Ninject/Components/ComponentContainer.cs b/src/Ninject/Components/ComponentContainer.cs
index 743d484..29fef62 100644
--- a/src/Ninject/Components/ComponentContainer.cs
+++ b/src/Ninject/Components/ComponentContainer.cs
@@ -4,7 +4,7 @@ using System.Linq;
 using System.Reflection;
 using Ninject.Infrastructure;
 using Ninject.Infrastructure.Disposal;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Components
 {
diff --git a/src/Ninject/Infrastructure/KernelHook.cs b/src/Ninject/Infrastructure/KernelHook.cs
deleted file mode 100644
index 3678673..0000000
--- a/src/Ninject/Infrastructure/KernelHook.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-﻿using System;
-using Ninject.Activation;
-
-namespace Ninject.Infrastructure
-{
-	public class KernelHook : IHook
-	{
-		public IKernel Kernel { get; private set; }
-
-		public KernelHook(IKernel kernel)
-		{
-			Kernel = kernel;
-		}
-
-		public object Resolve()
-		{
-			return Kernel;
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/Ninject/Syntax/ExtensionsForEventHandler.cs b/src/Ninject/Infrastructure/Language/ExtensionsForEventHandler.cs
similarity index 67%
rename from src/Ninject/Syntax/ExtensionsForEventHandler.cs
rename to src/Ninject/Infrastructure/Language/ExtensionsForEventHandler.cs
index 13c3ac7..2c1d9ce 100644
--- a/src/Ninject/Syntax/ExtensionsForEventHandler.cs
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForEventHandler.cs
@@ -1,8 +1,8 @@
 ﻿using System;
 
-namespace Ninject.Syntax
+namespace Ninject.Infrastructure.Language
 {
-	public static class ExtensionsForEventHandler
+	internal static class ExtensionsForEventHandler
 	{
 		public static void Raise<T>(this EventHandler<T> handler, object sender, T message)
 			where T : EventArgs
diff --git a/src/Ninject/Syntax/ExtensionsForICollection.cs b/src/Ninject/Infrastructure/Language/ExtensionsForICollection.cs
similarity index 71%
rename from src/Ninject/Syntax/ExtensionsForICollection.cs
rename to src/Ninject/Infrastructure/Language/ExtensionsForICollection.cs
index a456a28..cbbac50 100644
--- a/src/Ninject/Syntax/ExtensionsForICollection.cs
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForICollection.cs
@@ -2,9 +2,9 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace Ninject.Syntax
+namespace Ninject.Infrastructure.Language
 {
-	public static class ExtensionsForICollection
+	internal static class ExtensionsForICollection
 	{
 		public static void RemoveWhere<T>(this ICollection<T> collection, Func<T, bool> condition)
 		{
diff --git a/src/Ninject/Syntax/ExtensionsForICustomAttributeProvider.cs b/src/Ninject/Infrastructure/Language/ExtensionsForICustomAttributeProvider.cs
similarity index 87%
rename from src/Ninject/Syntax/ExtensionsForICustomAttributeProvider.cs
rename to src/Ninject/Infrastructure/Language/ExtensionsForICustomAttributeProvider.cs
index 2182ff4..e231192 100644
--- a/src/Ninject/Syntax/ExtensionsForICustomAttributeProvider.cs
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForICustomAttributeProvider.cs
@@ -3,9 +3,9 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
 
-namespace Ninject.Syntax
+namespace Ninject.Infrastructure.Language
 {
-	public static class ExtensionsForICustomAttributeProvider
+	internal static class ExtensionsForICustomAttributeProvider
 	{
 		public static T GetOneAttribute<T>(this ICustomAttributeProvider member)
 			where T : Attribute
diff --git a/src/Ninject/Infrastructure/Language/ExtensionsForIEnumerable.cs b/src/Ninject/Infrastructure/Language/ExtensionsForIEnumerable.cs
new file mode 100644
index 0000000..fc006c0
--- /dev/null
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForIEnumerable.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Ninject.Infrastructure.Language
+{
+	internal static class ExtensionsForIEnumerable
+	{
+		public static void Map<T>(this IEnumerable<T> series, Action<T> action)
+		{
+			foreach (T item in series)
+				action(item);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/Ninject/Syntax/ExtensionsForIList.cs b/src/Ninject/Infrastructure/Language/ExtensionsForIList.cs
similarity index 76%
rename from src/Ninject/Syntax/ExtensionsForIList.cs
rename to src/Ninject/Infrastructure/Language/ExtensionsForIList.cs
index 0cf7d34..3b6d520 100644
--- a/src/Ninject/Syntax/ExtensionsForIList.cs
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForIList.cs
@@ -1,9 +1,9 @@
 ﻿using System;
 using System.Collections.Generic;
 
-namespace Ninject.Syntax
+namespace Ninject.Infrastructure.Language
 {
-	public static class ExtensionsForIList
+	internal static class ExtensionsForIList
 	{
 		public static bool ElementsEqual<T>(this IList<T> collection, IList<T> other)
 		{
diff --git a/src/Ninject/Syntax/ExtensionsForTargetInvocationException.cs b/src/Ninject/Infrastructure/Language/ExtensionsForTargetInvocationException.cs
similarity index 78%
rename from src/Ninject/Syntax/ExtensionsForTargetInvocationException.cs
rename to src/Ninject/Infrastructure/Language/ExtensionsForTargetInvocationException.cs
index bf99aae..232f0b1 100644
--- a/src/Ninject/Syntax/ExtensionsForTargetInvocationException.cs
+++ b/src/Ninject/Infrastructure/Language/ExtensionsForTargetInvocationException.cs
@@ -1,9 +1,9 @@
 ﻿using System;
 using System.Reflection;
 
-namespace Ninject.Syntax
+namespace Ninject.Infrastructure.Language
 {
-	public static class ExtensionsForTargetInvocationException
+	internal static class ExtensionsForTargetInvocationException
 	{
 		public static void RethrowInnerException(this TargetInvocationException exception)
 		{
diff --git a/src/Ninject/KernelBase.cs b/src/Ninject/KernelBase.cs
index b17137e..64622d9 100644
--- a/src/Ninject/KernelBase.cs
+++ b/src/Ninject/KernelBase.cs
@@ -3,13 +3,14 @@ using System.Collections.Generic;
 using System.Linq;
 using Ninject.Activation;
 using Ninject.Activation.Caching;
-using Ninject.Activation.Constraints;
+using Ninject.Activation.Hooks;
 using Ninject.Activation.Providers;
 using Ninject.Activation.Scope;
 using Ninject.Components;
 using Ninject.Events;
 using Ninject.Infrastructure;
 using Ninject.Infrastructure.Disposal;
+using Ninject.Infrastructure.Language;
 using Ninject.Modules;
 using Ninject.Parameters;
 using Ninject.Planning.Bindings;
@@ -100,7 +101,7 @@ namespace Ninject
 			return false;
 		}
 
-		public virtual IEnumerable<IHook> Resolve(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters)
+		public virtual IEnumerable<IHook> Resolve(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters)
 		{
 			return Resolve(CreateDirectRequest(service, constraints, parameters));
 		}
@@ -108,9 +109,7 @@ namespace Ninject
 		public virtual IEnumerable<IHook> Resolve(IRequest request)
 		{
 			if (request.Service.IsAssignableFrom(GetType()))
-			{
-				return new[] { new KernelHook(this) };
-			}
+				return new[] { new ConstantHook(this) };
 
 			if (!CanResolve(request))
 			{
@@ -119,8 +118,8 @@ namespace Ninject
 			}
 
 			return GetBindings(request)
-				.Where(binding => binding.Matches(request) && request.ConstraintsSatisfiedBy(binding))
-				.Select(binding => CreateContext(request, binding)).Cast<IHook>();
+				.Where(binding => binding.ConditionsSatisfiedBy(request) && request.ConstraintsSatisfiedBy(binding))
+				.Select(binding => CreateHook(CreateContext(request, binding)));
 		}
 
 		public IBindingToSyntax<T> Bind<T>()
@@ -184,14 +183,19 @@ namespace Ninject
 			return new BindingBuilder<T>(binding);
 		}
 
-		protected virtual IRequest CreateDirectRequest(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters)
+		protected virtual IRequest CreateDirectRequest(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters)
 		{
 			return new Request(service, constraints, parameters, null);
 		}
 
 		protected virtual IContext CreateContext(IRequest request, IBinding binding)
 		{
-			return new Context(this, request, binding, Components.Get<ICache>());
+			return new Context(this, request, binding);
+		}
+
+		protected virtual IHook CreateHook(IContext context)
+		{
+			return new ContextResolutionHook(context, Components.Get<ICache>());
 		}
 
 		object IServiceProvider.GetService(Type serviceType)
diff --git a/src/Ninject/Modules/Module.cs b/src/Ninject/Modules/Module.cs
index b0d598a..ff2d7b9 100644
--- a/src/Ninject/Modules/Module.cs
+++ b/src/Ninject/Modules/Module.cs
@@ -1,6 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using Ninject.Events;
+using Ninject.Infrastructure.Language;
 using Ninject.Planning.Bindings;
 using Ninject.Syntax;
 
diff --git a/src/Ninject/Modules/ModuleLoader.cs b/src/Ninject/Modules/ModuleLoader.cs
index a3b6272..16fcad9 100644
--- a/src/Ninject/Modules/ModuleLoader.cs
+++ b/src/Ninject/Modules/ModuleLoader.cs
@@ -15,6 +15,9 @@ namespace Ninject.Modules
 		{
 			foreach (Type type in assembly.GetExportedTypes().Where(IsLoadableModule))
 			{
+				if (Kernel.HasModule(type))
+					continue;
+
 				var module = Activator.CreateInstance(type) as IModule;
 				Kernel.LoadModule(module);
 			}
@@ -78,9 +81,6 @@ namespace Ninject.Modules
 			if (!typeof(IModule).IsAssignableFrom(type) || type.IsAbstract || type.IsInterface)
 				return false;
 
-			if (type.HasAttribute<IgnoreModule>())
-				return false;
-
 			return type.GetConstructor(Type.EmptyTypes) != null;
 		}
 
diff --git a/src/Ninject/Ninject.csproj b/src/Ninject/Ninject.csproj
index b54da1d..e90e959 100644
--- a/src/Ninject/Ninject.csproj
+++ b/src/Ninject/Ninject.csproj
@@ -71,7 +71,8 @@
     <Compile Include="Activation\Context.cs">
       <SubType>Code</SubType>
     </Compile>
-    <Compile Include="Activation\IHook.cs" />
+    <Compile Include="Activation\Hooks\ContextResolutionHook.cs" />
+    <Compile Include="Activation\Hooks\IHook.cs" />
     <Compile Include="Activation\Request.cs" />
     <Compile Include="Activation\IContext.cs">
       <SubType>Code</SubType>
@@ -104,12 +105,12 @@
       <SubType>Code</SubType>
     </Compile>
     <Compile Include="Attributes\ConstraintAttribute.cs" />
-    <Compile Include="Attributes\IgnoreModule.cs" />
     <Compile Include="Attributes\InterceptAttribute.cs" />
     <Compile Include="Attributes\NamedAttribute.cs" />
     <Compile Include="Attributes\InjectAttribute.cs" />
-    <Compile Include="Infrastructure\KernelHook.cs" />
-    <Compile Include="ModuleLoadExtensions.cs" />
+    <Compile Include="Activation\Hooks\ConstantHook.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForIList.cs" />
+    <Compile Include="Syntax\ModuleLoadExtensions.cs" />
     <Compile Include="Events\BindingEventArgs.cs" />
     <Compile Include="Events\ModuleEventArgs.cs" />
     <Compile Include="Infrastructure\IHaveKernel.cs" />
@@ -125,8 +126,7 @@
     <Compile Include="Infrastructure\Disposal\DisposableObject.cs" />
     <Compile Include="Activation\Scope\IActivationScope.cs" />
     <Compile Include="Infrastructure\Disposal\INotifyWhenDisposed.cs" />
-    <Compile Include="Syntax\ExtensionsForEventHandler.cs" />
-    <Compile Include="Syntax\ExtensionsForIList.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForEventHandler.cs" />
     <Compile Include="Syntax\IResolutionRoot.cs" />
     <Compile Include="Activation\Scope\ActivationScope.cs" />
     <Compile Include="Infrastructure\FormatExtensions.cs" />
@@ -146,7 +146,7 @@
     <Compile Include="NinjectSettings.cs" />
     <Compile Include="Activation\Providers\StandardProvider.cs" />
     <Compile Include="Activation\Provider.cs" />
-    <Compile Include="ResolutionExtensions.cs" />
+    <Compile Include="Syntax\ResolutionExtensions.cs" />
     <Compile Include="Activation\Providers\ConstantProvider.cs" />
     <Compile Include="Infrastructure\LinqReflection.cs" />
     <Compile Include="Components\INinjectComponent.cs" />
@@ -176,8 +176,6 @@
     <Compile Include="Planning\Strategies\MethodReflectionStrategy.cs" />
     <Compile Include="Planning\Strategies\PropertyReflectionStrategy.cs" />
     <Compile Include="Planning\Targets\Target.cs" />
-    <Compile Include="Activation\Constraints\PredicateConstraint.cs" />
-    <Compile Include="Activation\Constraints\IConstraint.cs" />
     <Compile Include="Selection\Heuristics\StandardMethodInterceptionHeuristic.cs" />
     <Compile Include="Selection\Heuristics\StandardPropertyInjectionHeuristic.cs" />
     <Compile Include="Selection\Heuristics\IMethodInjectionHeuristic.cs" />
@@ -208,10 +206,10 @@
     <Compile Include="Planning\Bindings\BindingBuilder.cs" />
     <Compile Include="Planning\Bindings\Binding.cs" />
     <Compile Include="Infrastructure\Multimap.cs" />
-    <Compile Include="Syntax\ExtensionsForICollection.cs" />
-    <Compile Include="Syntax\ExtensionsForTargetInvocationException.cs" />
-    <Compile Include="Syntax\ExtensionsForICustomAttributeProvider.cs" />
-    <Compile Include="Syntax\ExtensionsForIEnumerable.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForICollection.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForTargetInvocationException.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForICustomAttributeProvider.cs" />
+    <Compile Include="Infrastructure\Language\ExtensionsForIEnumerable.cs" />
     <Compile Include="Syntax\BindingSyntax.cs" />
     <Compile Include="Planning\Bindings\IBinding.cs" />
     <Compile Include="IKernel.cs" />
diff --git a/src/Ninject/Parameters/Parameter.cs b/src/Ninject/Parameters/Parameter.cs
index f866dd3..3beeb20 100644
--- a/src/Ninject/Parameters/Parameter.cs
+++ b/src/Ninject/Parameters/Parameter.cs
@@ -5,21 +5,20 @@ namespace Ninject.Parameters
 {
 	public class Parameter : IParameter
 	{
-		private readonly Func<IContext, object> _valueCallback;
-
 		public string Name { get; private set; }
+		public Func<IContext, object> ValueCallback { get; private set; }
 
 		public Parameter(string name, object value) : this(name, ctx => value) { }
 
 		public Parameter(string name, Func<IContext, object> valueCallback)
 		{
 			Name = name;
-			_valueCallback = valueCallback;
+			ValueCallback = valueCallback;
 		}
 
 		public object GetValue(IContext context)
 		{
-			return _valueCallback(context);
+			return ValueCallback(context);
 		}
 
 		public override bool Equals(object obj)
diff --git a/src/Ninject/Planning/Bindings/Binding.cs b/src/Ninject/Planning/Bindings/Binding.cs
index 2aaf6da..1c3d9aa 100644
--- a/src/Ninject/Planning/Bindings/Binding.cs
+++ b/src/Ninject/Planning/Bindings/Binding.cs
@@ -1,6 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Ninject.Activation;
 using Ninject.Infrastructure;
 using Ninject.Infrastructure.Tracing;
@@ -13,12 +14,13 @@ namespace Ninject.Planning.Bindings
 	{
 		private IProvider _provider;
 
-		public Type Service { get; set; }
-		public IBindingMetadata Metadata { get; set; }
+		public Type Service { get; private set; }
+		public IBindingMetadata Metadata { get; private set; }
+
+		public ICollection<Func<IRequest, bool>> Conditions { get; private set; }
 		public ICollection<IParameter> Parameters { get; private set; }
 
 		public Func<IContext, IProvider> ProviderCallback { get; set; }
-		public Func<IRequest, bool> ConditionCallback { get; set; }
 		public Func<IContext, object> ScopeCallback { get; set; }
 
 		public string IntrospectionInfo { get; set; }
@@ -29,6 +31,7 @@ namespace Ninject.Planning.Bindings
 		{
 			Service = service;
 			Metadata = metadata;
+			Conditions = new List<Func<IRequest, bool>>();
 			Parameters = new List<IParameter>();
 			IntrospectionInfo = "Binding from " + service.Format();
 		}
@@ -46,9 +49,9 @@ namespace Ninject.Planning.Bindings
 			return ScopeCallback == null ? null : ScopeCallback(context);
 		}
 
-		public bool Matches(IRequest request)
+		public bool ConditionsSatisfiedBy(IRequest request)
 		{
-			return ConditionCallback == null || ConditionCallback(request);
+			return Conditions.All(condition => condition(request));
 		}
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Planning/Bindings/BindingBuilder.cs b/src/Ninject/Planning/Bindings/BindingBuilder.cs
index 7d8ae05..31f2284 100644
--- a/src/Ninject/Planning/Bindings/BindingBuilder.cs
+++ b/src/Ninject/Planning/Bindings/BindingBuilder.cs
@@ -13,7 +13,7 @@ namespace Ninject.Planning.Bindings
 {
 	public class BindingBuilder<T> : IBindingToSyntax<T>, IBindingWhenInNamedOrWithSyntax<T>, IBindingInNamedOrWithSyntax<T>, IBindingNamedOrWithSyntax<T>
 	{
-		public Binding Binding { get; set; }
+		public Binding Binding { get; private set; }
 
 		public BindingBuilder(Binding binding)
 		{
@@ -70,9 +70,9 @@ namespace Ninject.Planning.Bindings
 			return this;
 		}
 
-		public IBindingInNamedOrWithSyntax<T> When(Func<IRequest, bool> condition)
+		public IBindingWhenInNamedOrWithSyntax<T> When(Func<IRequest, bool> condition)
 		{
-			Binding.ConditionCallback = condition;
+			Binding.Conditions.Add(condition);
 			Binding.IntrospectionInfo += " (conditionally)";
 			return this;
 		}
diff --git a/src/Ninject/Planning/Bindings/IBinding.cs b/src/Ninject/Planning/Bindings/IBinding.cs
index 711c505..9b5109e 100644
--- a/src/Ninject/Planning/Bindings/IBinding.cs
+++ b/src/Ninject/Planning/Bindings/IBinding.cs
@@ -10,10 +10,12 @@ namespace Ninject.Planning.Bindings
 	{
 		Type Service { get; }
 		IBindingMetadata Metadata { get; }
+
+		ICollection<Func<IRequest, bool>> Conditions { get; }
 		ICollection<IParameter> Parameters { get; }
 
 		IProvider GetProvider(IContext context);
 		object GetScope(IContext context);
-		bool Matches(IRequest request);
+		bool ConditionsSatisfiedBy(IRequest request);
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Planning/Directives/MultipleInjectionDirective.cs b/src/Ninject/Planning/Directives/MultipleInjectionDirective.cs
index fc8d6c5..1ab4c0d 100644
--- a/src/Ninject/Planning/Directives/MultipleInjectionDirective.cs
+++ b/src/Ninject/Planning/Directives/MultipleInjectionDirective.cs
@@ -8,8 +8,8 @@ namespace Ninject.Planning.Directives
 	public abstract class MultipleInjectionDirective<T> : IDirective
 		where T : MethodBase
 	{
-		public T Member { get; set; }
-		public ITarget[] Targets { get; set; }
+		public T Member { get; private set; }
+		public ITarget[] Targets { get; private set; }
 
 		protected MultipleInjectionDirective(T member)
 		{
diff --git a/src/Ninject/Planning/Directives/PropertyInjectionDirective.cs b/src/Ninject/Planning/Directives/PropertyInjectionDirective.cs
index 879e0b5..076d01b 100644
--- a/src/Ninject/Planning/Directives/PropertyInjectionDirective.cs
+++ b/src/Ninject/Planning/Directives/PropertyInjectionDirective.cs
@@ -6,8 +6,8 @@ namespace Ninject.Planning.Directives
 {
 	public class PropertyInjectionDirective : IDirective
 	{
-		public PropertyInfo Member { get; set; }
-		public ITarget Target { get; set; }
+		public PropertyInfo Member { get; private set; }
+		public ITarget Target { get; private set; }
 
 		public PropertyInjectionDirective(PropertyInfo member)
 		{
diff --git a/src/Ninject/Planning/Plan.cs b/src/Ninject/Planning/Plan.cs
index e7065bb..32cc3e0 100644
--- a/src/Ninject/Planning/Plan.cs
+++ b/src/Ninject/Planning/Plan.cs
@@ -7,18 +7,18 @@ namespace Ninject.Planning
 {
 	public class Plan : IPlan
 	{
-		private readonly List<IDirective> _directives = new List<IDirective>();
-
 		public Type Type { get; private set; }
+		public ICollection<IDirective> Directives { get; private set; }
 
 		public Plan(Type type)
 		{
 			Type = type;
+			Directives = new List<IDirective>();
 		}
 
 		public void Add(IDirective directive)
 		{
-			_directives.Add(directive);
+			Directives.Add(directive);
 		}
 
 		public bool Has<TDirective>()
@@ -36,7 +36,7 @@ namespace Ninject.Planning
 		public IEnumerable<TDirective> GetAll<TDirective>()
 			where TDirective : IDirective
 		{
-			return _directives.OfType<TDirective>();
+			return Directives.OfType<TDirective>();
 		}
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Planning/Planner.cs b/src/Ninject/Planning/Planner.cs
index 89b0ede..4d1eecf 100644
--- a/src/Ninject/Planning/Planner.cs
+++ b/src/Ninject/Planning/Planner.cs
@@ -2,8 +2,8 @@
 using System.Collections.Generic;
 using System.Linq;
 using Ninject.Components;
+using Ninject.Infrastructure.Language;
 using Ninject.Planning.Strategies;
-using Ninject.Syntax;
 
 namespace Ninject.Planning
 {
@@ -23,12 +23,17 @@ namespace Ninject.Planning
 			if (_plans.ContainsKey(type))
 				return _plans[type];
 
-			var plan = new Plan(type);
+			var plan = CreateEmptyPlan(type);
 			_plans.Add(type, plan);
 
 			Strategies.Map(s => s.Execute(plan));
 
 			return plan;
 		}
+
+		protected virtual IPlan CreateEmptyPlan(Type type)
+		{
+			return new Plan(type);
+		}
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Planning/Strategies/ConstructorReflectionStrategy.cs b/src/Ninject/Planning/Strategies/ConstructorReflectionStrategy.cs
index 4b10623..2cba580 100644
--- a/src/Ninject/Planning/Strategies/ConstructorReflectionStrategy.cs
+++ b/src/Ninject/Planning/Strategies/ConstructorReflectionStrategy.cs
@@ -8,7 +8,7 @@ namespace Ninject.Planning.Strategies
 {
 	public class ConstructorReflectionStrategy : NinjectComponent, IPlanningStrategy
 	{
-		public ISelector Selector { get; set; }
+		public ISelector Selector { get; private set; }
 
 		public ConstructorReflectionStrategy(ISelector selector)
 		{
diff --git a/src/Ninject/Planning/Strategies/MethodInterceptionStrategy.cs b/src/Ninject/Planning/Strategies/MethodInterceptionStrategy.cs
index f660a5a..1b25bbd 100644
--- a/src/Ninject/Planning/Strategies/MethodInterceptionStrategy.cs
+++ b/src/Ninject/Planning/Strategies/MethodInterceptionStrategy.cs
@@ -8,7 +8,7 @@ namespace Ninject.Planning.Strategies
 {
 	public class MethodInterceptionStrategy : NinjectComponent, IPlanningStrategy
 	{
-		public ISelector Selector { get; set; }
+		public ISelector Selector { get; private set; }
 
 		public MethodInterceptionStrategy(ISelector selector)
 		{
diff --git a/src/Ninject/Planning/Strategies/MethodReflectionStrategy.cs b/src/Ninject/Planning/Strategies/MethodReflectionStrategy.cs
index 093b7d5..669efbc 100644
--- a/src/Ninject/Planning/Strategies/MethodReflectionStrategy.cs
+++ b/src/Ninject/Planning/Strategies/MethodReflectionStrategy.cs
@@ -8,7 +8,7 @@ namespace Ninject.Planning.Strategies
 {
 	public class MethodReflectionStrategy : NinjectComponent, IPlanningStrategy
 	{
-		public ISelector Selector { get; set; }
+		public ISelector Selector { get; private set; }
 
 		public MethodReflectionStrategy(ISelector selector)
 		{
diff --git a/src/Ninject/Planning/Strategies/PropertyReflectionStrategy.cs b/src/Ninject/Planning/Strategies/PropertyReflectionStrategy.cs
index 4e977e3..962d6fa 100644
--- a/src/Ninject/Planning/Strategies/PropertyReflectionStrategy.cs
+++ b/src/Ninject/Planning/Strategies/PropertyReflectionStrategy.cs
@@ -8,7 +8,7 @@ namespace Ninject.Planning.Strategies
 {
 	public class PropertyReflectionStrategy : NinjectComponent, IPlanningStrategy
 	{
-		public ISelector Selector { get; set; }
+		public ISelector Selector { get; private set; }
 
 		public PropertyReflectionStrategy(ISelector selector)
 		{
diff --git a/src/Ninject/Planning/Targets/ITarget.cs b/src/Ninject/Planning/Targets/ITarget.cs
index 958d1e1..ad9c365 100644
--- a/src/Ninject/Planning/Targets/ITarget.cs
+++ b/src/Ninject/Planning/Targets/ITarget.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using Ninject.Activation;
-using Ninject.Activation.Constraints;
+using Ninject.Planning.Bindings;
 
 namespace Ninject.Planning.Targets
 {
@@ -9,7 +9,7 @@ namespace Ninject.Planning.Targets
 	{
 		Type Type { get; }
 		string Name { get; }
-		IEnumerable<IConstraint> GetConstraints();
+		IEnumerable<Func<IBindingMetadata, bool>> GetConstraints();
 		object ResolveWithin(IContext parent);
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/Planning/Targets/Target.cs b/src/Ninject/Planning/Targets/Target.cs
index 6952058..598595b 100644
--- a/src/Ninject/Planning/Targets/Target.cs
+++ b/src/Ninject/Planning/Targets/Target.cs
@@ -3,9 +3,9 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
 using Ninject.Activation;
-using Ninject.Activation.Constraints;
 using Ninject.Infrastructure;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
+using Ninject.Planning.Bindings;
 
 namespace Ninject.Planning.Targets
 {
@@ -22,9 +22,9 @@ namespace Ninject.Planning.Targets
 			Site = site;
 		}
 
-		public IEnumerable<IConstraint> GetConstraints()
+		public IEnumerable<Func<IBindingMetadata, bool>> GetConstraints()
 		{
-			return Site.GetAttributes<ConstraintAttribute>().Cast<IConstraint>();
+			return Site.GetAttributes<ConstraintAttribute>().Select(a => new Func<IBindingMetadata, bool>(a.Matches));
 		}
 
 		public object ResolveWithin(IContext parent)
diff --git a/src/Ninject/Selection/Heuristics/StandardConstructorScorer.cs b/src/Ninject/Selection/Heuristics/StandardConstructorScorer.cs
index c7f9f4a..992a912 100644
--- a/src/Ninject/Selection/Heuristics/StandardConstructorScorer.cs
+++ b/src/Ninject/Selection/Heuristics/StandardConstructorScorer.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Reflection;
 using Ninject.Components;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Selection.Heuristics
 {
diff --git a/src/Ninject/Selection/Heuristics/StandardMethodInjectionHeuristic.cs b/src/Ninject/Selection/Heuristics/StandardMethodInjectionHeuristic.cs
index fc6d7cf..d128413 100644
--- a/src/Ninject/Selection/Heuristics/StandardMethodInjectionHeuristic.cs
+++ b/src/Ninject/Selection/Heuristics/StandardMethodInjectionHeuristic.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Reflection;
 using Ninject.Components;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Selection.Heuristics
 {
diff --git a/src/Ninject/Selection/Heuristics/StandardMethodInterceptionHeuristic.cs b/src/Ninject/Selection/Heuristics/StandardMethodInterceptionHeuristic.cs
index fad5089..2200e0f 100644
--- a/src/Ninject/Selection/Heuristics/StandardMethodInterceptionHeuristic.cs
+++ b/src/Ninject/Selection/Heuristics/StandardMethodInterceptionHeuristic.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Reflection;
 using Ninject.Components;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Selection.Heuristics
 {
diff --git a/src/Ninject/Selection/Heuristics/StandardPropertyInjectionHeuristic.cs b/src/Ninject/Selection/Heuristics/StandardPropertyInjectionHeuristic.cs
index e57f21c..c552b1f 100644
--- a/src/Ninject/Selection/Heuristics/StandardPropertyInjectionHeuristic.cs
+++ b/src/Ninject/Selection/Heuristics/StandardPropertyInjectionHeuristic.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Reflection;
 using Ninject.Components;
-using Ninject.Syntax;
+using Ninject.Infrastructure.Language;
 
 namespace Ninject.Selection.Heuristics
 {
diff --git a/src/Ninject/Syntax/BindingSyntax.cs b/src/Ninject/Syntax/BindingSyntax.cs
index ad061d2..0e58f25 100644
--- a/src/Ninject/Syntax/BindingSyntax.cs
+++ b/src/Ninject/Syntax/BindingSyntax.cs
@@ -17,7 +17,7 @@ namespace Ninject.Syntax
 
 	public interface IBindingWhenSyntax<T> : IFluentSyntax
 	{
-		IBindingInNamedOrWithSyntax<T> When(Func<IRequest, bool> condition);
+		IBindingWhenInNamedOrWithSyntax<T> When(Func<IRequest, bool> condition);
 	}
 
 	public interface IBindingInSyntax<T> : IFluentSyntax
diff --git a/src/Ninject/Syntax/IResolutionRoot.cs b/src/Ninject/Syntax/IResolutionRoot.cs
index 852fa95..f1aff13 100644
--- a/src/Ninject/Syntax/IResolutionRoot.cs
+++ b/src/Ninject/Syntax/IResolutionRoot.cs
@@ -1,15 +1,16 @@
 ﻿using System;
 using System.Collections.Generic;
 using Ninject.Activation;
-using Ninject.Activation.Constraints;
+using Ninject.Activation.Hooks;
 using Ninject.Parameters;
+using Ninject.Planning.Bindings;
 
 namespace Ninject.Syntax
 {
 	public interface IResolutionRoot : IServiceProvider
 	{
 		bool CanResolve(IRequest request);
-		IEnumerable<IHook> Resolve(Type service, IEnumerable<IConstraint> constraints, IEnumerable<IParameter> parameters);
+		IEnumerable<IHook> Resolve(Type service, IEnumerable<Func<IBindingMetadata, bool>> constraints, IEnumerable<IParameter> parameters);
 		IEnumerable<IHook> Resolve(IRequest request);
 	}
 }
\ No newline at end of file
diff --git a/src/Ninject/ModuleLoadExtensions.cs b/src/Ninject/Syntax/ModuleLoadExtensions.cs
similarity index 100%
rename from src/Ninject/ModuleLoadExtensions.cs
rename to src/Ninject/Syntax/ModuleLoadExtensions.cs
diff --git a/src/Ninject/ResolutionExtensions.cs b/src/Ninject/Syntax/ResolutionExtensions.cs
similarity index 64%
rename from src/Ninject/ResolutionExtensions.cs
rename to src/Ninject/Syntax/ResolutionExtensions.cs
index 6e7a2e8..947f1ed 100644
--- a/src/Ninject/ResolutionExtensions.cs
+++ b/src/Ninject/Syntax/ResolutionExtensions.cs
@@ -1,7 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
-using Ninject.Activation.Constraints;
 using Ninject.Parameters;
 using Ninject.Planning.Bindings;
 using Ninject.Syntax;
@@ -12,7 +11,7 @@ namespace Ninject
 	{
 		public static T Get<T>(this IResolutionRoot root, params IParameter[] parameters)
 		{
-			return root.Resolve(typeof(T), new IConstraint[0], parameters).Select(ctx => ctx.Resolve()).Cast<T>().FirstOrDefault();
+			return root.Resolve(typeof(T), null, parameters).Select(ctx => ctx.Resolve()).Cast<T>().FirstOrDefault();
 		}
 
 		public static T Get<T>(this IResolutionRoot root, string name, params IParameter[] parameters)
@@ -22,12 +21,12 @@ namespace Ninject
 
 		public static T Get<T>(this IResolutionRoot root, Func<IBindingMetadata, bool> predicate, params IParameter[] parameters)
 		{
-			return (T)root.Resolve(typeof(T), new[] { new PredicateConstraint(predicate) }, parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
+			return (T)root.Resolve(typeof(T), new[] { predicate }, parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
 		}
 
 		public static IEnumerable<T> GetAll<T>(this IResolutionRoot root, params IParameter[] parameters)
 		{
-			return root.Resolve(typeof(T), new IConstraint[0], parameters).Select(ctx => ctx.Resolve()).Cast<T>();
+			return root.Resolve(typeof(T), null, parameters).Select(ctx => ctx.Resolve()).Cast<T>();
 		}
 
 		public static IEnumerable<T> GetAll<T>(this IResolutionRoot root, string name, params IParameter[] parameters)
@@ -37,12 +36,12 @@ namespace Ninject
 
 		public static IEnumerable<T> GetAll<T>(this IResolutionRoot root, Func<IBindingMetadata, bool> predicate, params IParameter[] parameters)
 		{
-			return root.Resolve(typeof(T), new[] { new PredicateConstraint(predicate) }, parameters).Select(ctx => ctx.Resolve()).Cast<T>();
+			return root.Resolve(typeof(T), new[] { predicate }, parameters).Select(ctx => ctx.Resolve()).Cast<T>();
 		}
 
 		public static object Get(this IResolutionRoot root, Type type, params IParameter[] parameters)
 		{
-			return root.Resolve(type, new IConstraint[0], parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
+			return root.Resolve(type, null, parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
 		}
 
 		public static object Get(this IResolutionRoot root, Type type, string name, params IParameter[] parameters)
@@ -52,12 +51,12 @@ namespace Ninject
 
 		public static object Get(this IResolutionRoot root, Type type, Func<IBindingMetadata, bool> predicate, params IParameter[] parameters)
 		{
-			return root.Resolve(type, new[] { new PredicateConstraint(predicate) }, parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
+			return root.Resolve(type, new[] { predicate }, parameters).Select(ctx => ctx.Resolve()).FirstOrDefault();
 		}
 
 		public static IEnumerable<object> GetAll(this IResolutionRoot root, Type type, params IParameter[] parameters)
 		{
-			return root.Resolve(type, new IConstraint[0], parameters).Select(ctx => ctx.Resolve());
+			return root.Resolve(type, null, parameters).Select(ctx => ctx.Resolve());
 		}
 
 		public static IEnumerable<object> GetAll(this IResolutionRoot root, Type type, string name, params IParameter[] parameters)
@@ -67,7 +66,7 @@ namespace Ninject
 
 		public static IEnumerable<object> GetAll(this IResolutionRoot root, Type type, Func<IBindingMetadata, bool> predicate, params IParameter[] parameters)
 		{
-			return root.Resolve(type, new[] { new PredicateConstraint(predicate) }, parameters).Select(ctx => ctx.Resolve());
+			return root.Resolve(type, new[] { predicate }, parameters).Select(ctx => ctx.Resolve());
 		}
 	}
 }

ATOMIC:	NO, sync with TRUNK


PROJECT:	Newtonsoft.Json
SHA:	b270104bfbb9d3ec9f813fb9c2b2c439437898dd
DIFF:
commit b270104bfbb9d3ec9f813fb9c2b2c439437898dd
Author: James Newton-King <james@newtonking.com>
Date:   Fri Jun 12 09:59:20 2015 +1200

    -Fixed writing ULong.MaxValue JValues as JSON

diff --git a/Src/Newtonsoft.Json.Tests/Linq/LinqToJsonTest.cs b/Src/Newtonsoft.Json.Tests/Linq/LinqToJsonTest.cs
index d1d29edf..8e5adb77 100644
--- a/Src/Newtonsoft.Json.Tests/Linq/LinqToJsonTest.cs
+++ b/Src/Newtonsoft.Json.Tests/Linq/LinqToJsonTest.cs
@@ -54,6 +54,38 @@ namespace Newtonsoft.Json.Tests.Linq
     [TestFixture]
     public class LinqToJsonTest : TestFixtureBase
     {
+        public class TestClass_ULong
+        {
+            public ulong Value { get; set; }
+        }
+
+        [Test]
+        public void FromObject_ULongMaxValue()
+        {
+            TestClass_ULong instance = new TestClass_ULong { Value = ulong.MaxValue };
+            JObject output = JObject.FromObject(instance);
+
+            StringAssert.AreEqual(@"{
+  ""Value"": 18446744073709551615
+}", output.ToString());
+        }
+
+        public class TestClass_Byte
+        {
+            public byte Value { get; set; }
+        }
+
+        [Test]
+        public void FromObject_ByteMaxValue()
+        {
+            TestClass_Byte instance = new TestClass_Byte { Value = byte.MaxValue };
+            JObject output = JObject.FromObject(instance);
+
+            StringAssert.AreEqual(@"{
+  ""Value"": 255
+}", output.ToString());
+        }
+
         [Test]
         public void ToObject_Base64AndGuid()
         {
diff --git a/Src/Newtonsoft.Json/Linq/JValue.cs b/Src/Newtonsoft.Json/Linq/JValue.cs
index ad24700c..0033ca34 100644
--- a/Src/Newtonsoft.Json/Linq/JValue.cs
+++ b/Src/Newtonsoft.Json/Linq/JValue.cs
@@ -676,11 +676,17 @@ public override void WriteTo(JsonWriter writer, params JsonConverter[] converter
                     writer.WriteUndefined();
                     return;
                 case JTokenType.Integer:
+                    if (_value is int)
+                        writer.WriteValue((int)_value);
+                    else if (_value is long)
+                        writer.WriteValue((long)_value);
+                    else if (_value is ulong)
+                        writer.WriteValue((ulong)_value);
 #if !(NET20 || NET35 || PORTABLE40 || PORTABLE)
-                    if (_value is BigInteger)
+                    else if (_value is BigInteger)
                         writer.WriteValue((BigInteger)_value);
-                    else
 #endif
+                    else
                         writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
                     return;
                 case JTokenType.Float:

ATOMIC:	Yes


PROJECT:	Lean
SHA:	8e745ffd60cd53e26911fcd24b9390e466729364
DIFF:
commit 8e745ffd60cd53e26911fcd24b9390e466729364
Author: Xiang Li <lixiang.lx618@gmail.com>
Date:   Thu Jul 27 17:27:41 2017 -0400

    Update CallingRFromCSharp.cs

diff --git a/Algorithm.CSharp/CallingRFromCSharp.cs b/Algorithm.CSharp/CallingRFromCSharp.cs
index 31b26b11..dff86b31 100644
--- a/Algorithm.CSharp/CallingRFromCSharp.cs
+++ b/Algorithm.CSharp/CallingRFromCSharp.cs
@@ -25,7 +25,6 @@
      public class CallingRFromCSharp : QCAlgorithm		
      {		
          private Symbol _spy = QuantConnect.Symbol.Create("SPY", SecurityType.Equity, Market.USA);		
-         REngine engine = REngine.GetInstance();		
  		
          /// <summary>		
          /// Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.		
@@ -38,6 +37,7 @@
              // Find more symbols here: http://quantconnect.com/data		
              AddEquity("SPY", Resolution.Second);		
              		
+             REngine engine = REngine.GetInstance();		
              engine.Evaluate("print('This is from R command.')");		
              // .NET Framework array to R vector.		
              NumericVector group1 = engine.CreateNumericVector(new double[] { 30.02, 29.99, 30.11, 29.97, 30.01, 29.99 });		

ATOMIC:	YES


PROJECT:	Nancy
SHA:	281510c73172ae464132452a27c54f4d84bac5a6
DIFF:
commit 281510c73172ae464132452a27c54f4d84bac5a6
Author: Andreas Hakansson <andreas@selfinflicted.org>
Date:   Tue Jul 9 21:30:38 2013 +0200

    Updated SharedAssemblyInfo to v0.18.0

diff --git a/src/SharedAssemblyInfo.cs b/src/SharedAssemblyInfo.cs
index e2593384..2f042b5d 100644
--- a/src/SharedAssemblyInfo.cs
+++ b/src/SharedAssemblyInfo.cs
@@ -6,5 +6,5 @@ using System.Reflection;
 [assembly: AssemblyCompany("Nancy")]
 [assembly: AssemblyProduct("Nancy")]
 [assembly: AssemblyCopyright("Copyright (C) Andreas Hakansson, Steven Robbins and contributors")]
-[assembly: AssemblyVersion("0.17.1")]
-[assembly: AssemblyInformationalVersion("0.17.1")]
+[assembly: AssemblyVersion("0.18.0")]
+[assembly: AssemblyInformationalVersion("0.18.0")]

ATOMIC:	YES


PROJECT:	Hangfire
SHA:	6773b5d312f3ef27539ee2178c3492231c57bfc2
DIFF:
commit 6773b5d312f3ef27539ee2178c3492231c57bfc2
Author: odinserj <odinserj@gmail.com>
Date:   Tue Apr 15 18:32:55 2014 +0400

    Fixed view path comments in tutorial

diff --git a/docs/tutorials/highlight.rst b/docs/tutorials/highlight.rst
index 075b8d56..0620bb69 100644
--- a/docs/tutorials/highlight.rst
+++ b/docs/tutorials/highlight.rst
@@ -229,7 +229,7 @@ Now its time to breathe life into our project. Please, modify the following file
 
 .. code-block:: html
 
-  @* ~/Views/Index.cshtml *@
+  @* ~/Views/Home/Index.cshtml *@
 
   @model IEnumerable<HangFire.Highlighter.Models.CodeSnippet>
   @{ ViewBag.Title = "Snippets"; }
@@ -258,7 +258,7 @@ Now its time to breathe life into our project. Please, modify the following file
 
 .. code-block:: html
 
-  @* ~/Views/Create.cshtml *@
+  @* ~/Views/Home/Create.cshtml *@
 
   @model HangFire.Highlighter.Models.CodeSnippet
   @{ ViewBag.Title = "Create a snippet"; }
@@ -281,7 +281,7 @@ Now its time to breathe life into our project. Please, modify the following file
 
 .. code-block:: html
 
-  @* ~/Views/Details.cshtml *@
+  @* ~/Views/Home/Details.cshtml *@
 
   @model HangFire.Highlighter.Models.CodeSnippet
   @{ ViewBag.Title = "Details"; }
@@ -596,6 +596,8 @@ In our example, we'll simply show the notification to a user and the un-highligh
 
 .. code-block:: html
 
+  @* ~/Views/Home/Details.cshtml *@
+
   <div>
       @if (Model.HighlightedCode == null)
       {

ATOMIC:	YES


PROJECT:	Hangfire
SHA:	461b673b62e0707cdb16f60d5bf1080bf1fb52b5
DIFF:
commit 461b673b62e0707cdb16f60d5bf1080bf1fb52b5
Author: Sergey Odinokov <odinserj@gmail.com>
Date:   Tue Mar 22 19:48:44 2016 +0300

    Use Visual Studio 2015 image on AppVeyor

diff --git a/appveyor.yml b/appveyor.yml
index 32ca6fc1..4d76f897 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -9,6 +9,8 @@
 # Don't edit manually! Use `build.bat version` command instead!
 version: 1.5.4-build-0{build}
 
+os: Visual Studio 2015
+
 #---------------------------------#
 #    environment configuration    #
 #---------------------------------#

ATOMIC:	YES


PROJECT:	Newtonsoft.Json
SHA:	9c2a1d853d7b1818b83726cdbb5aaf6bbc7485fc
DIFF:
commit 9c2a1d853d7b1818b83726cdbb5aaf6bbc7485fc
Author: James Newton-King <james@newtonking.com>
Date:   Sun Dec 7 16:31:52 2014 +1300

    -Fixed build

diff --git a/Src/Newtonsoft.Json.TestConsole/Properties/AssemblyInfo.cs b/Src/Newtonsoft.Json.TestConsole/Properties/AssemblyInfo.cs
index 9c8d4d43..8a33554f 100644
--- a/Src/Newtonsoft.Json.TestConsole/Properties/AssemblyInfo.cs
+++ b/Src/Newtonsoft.Json.TestConsole/Properties/AssemblyInfo.cs
@@ -33,4 +33,4 @@
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("6.0.0.0")]
 [assembly: AssemblyVersion("6.0.0.0")]
-[assembly: AssemblyFileVersion("6.0.7.18002")]
+[assembly: AssemblyFileVersion("6.0.7.18007")]
diff --git a/Src/Newtonsoft.Json.Tests/Linq/JTokenTests.cs b/Src/Newtonsoft.Json.Tests/Linq/JTokenTests.cs
index d9465a79..7a19a56c 100644
--- a/Src/Newtonsoft.Json.Tests/Linq/JTokenTests.cs
+++ b/Src/Newtonsoft.Json.Tests/Linq/JTokenTests.cs
@@ -25,7 +25,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Xml.Linq;
 #if !(NET20 || NET35 || PORTABLE || ASPNETCORE50)
 using System.Numerics;
 #endif
@@ -721,14 +720,6 @@ public void Descendants()
         [Test]
         public void DescendantsAndSelf()
         {
-            XElement e = new XElement("name");
-            e.Add(new XElement("child"));
-
-            var x = e.DescendantsAndSelf().ToList();
-            Assert.AreEqual(2, x.Count);
-            Assert.AreEqual(e, x[0]);
-            Assert.AreEqual(e.Element("child"), x[1]);
-
             JArray a =
                 new JArray(
                     5,
diff --git a/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs b/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
index 5bfb1f25..991cb458 100644
--- a/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
+++ b/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs
@@ -76,4 +76,4 @@
 // by using the '*' as shown below:
 
 [assembly: AssemblyVersion("6.0.0.0")]
-[assembly: AssemblyFileVersion("6.0.7.18002")]
+[assembly: AssemblyFileVersion("6.0.7.18007")]
diff --git a/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs b/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
index ef762883..0ddff139 100644
--- a/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
+++ b/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs
@@ -92,5 +92,5 @@
 // by using the '*' as shown below:
 
 [assembly: AssemblyVersion("6.0.0.0")]
-[assembly: AssemblyFileVersion("6.0.7.18002")]
+[assembly: AssemblyFileVersion("6.0.7.18007")]
 [assembly: CLSCompliant(true)]

ATOMIC:	YES


PROJECT:	Lean
SHA:	637c1537015a833ebdc6382e8f689917b649c7a5
DIFF:
commit 637c1537015a833ebdc6382e8f689917b649c7a5
Author: Stefano Raggi <stefano.raggi67@gmail.com>
Date:   Mon Apr 30 15:39:30 2018 +0200

    Add base OrderProperties class

diff --git a/Algorithm/QCAlgorithm.cs b/Algorithm/QCAlgorithm.cs
index cdf234e6..3ec9e20d 100644
--- a/Algorithm/QCAlgorithm.cs
+++ b/Algorithm/QCAlgorithm.cs
@@ -116,6 +116,7 @@ namespace QuantConnect.Algorithm
             _localTimeKeeper = _timeKeeper.GetLocalTimeKeeper(TimeZones.NewYork);
 
             Settings = new AlgorithmSettings();
+            DefaultOrderProperties = new OrderProperties();
 
             //Initialise Data Manager
             SubscriptionManager = new SubscriptionManager(Settings, _timeKeeper);
diff --git a/Brokerages/Fxcm/FxcmBrokerage.Util.cs b/Brokerages/Fxcm/FxcmBrokerage.Util.cs
index eb12e9ed..c6130c0b 100644
--- a/Brokerages/Fxcm/FxcmBrokerage.Util.cs
+++ b/Brokerages/Fxcm/FxcmBrokerage.Util.cs
@@ -69,7 +69,7 @@ namespace QuantConnect.Brokerages.Fxcm
             order.Quantity = Convert.ToInt32(fxcmOrder.getOrderQty() * (fxcmOrder.getSide() == SideFactory.BUY ? +1 : -1));
             order.Status = ConvertOrderStatus(fxcmOrder.getFXCMOrdStatus());
             order.BrokerId.Add(fxcmOrder.getOrderID());
-            order.TimeInForce = ConvertTimeInForce(fxcmOrder.getTimeInForce());
+            order.Properties.TimeInForce = ConvertTimeInForce(fxcmOrder.getTimeInForce());
             order.Time = FromJavaDate(fxcmOrder.getTransactTime().toDate());
 
             return order;
@@ -84,7 +84,7 @@ namespace QuantConnect.Brokerages.Fxcm
                 return TimeInForce.GoodTilCancelled;
 
             if (timeInForce == TimeInForceFactory.DAY)
-                return (TimeInForce)1; //.Day;
+                return TimeInForce.Day;
 
             throw new ArgumentOutOfRangeException();
         }
diff --git a/Brokerages/InteractiveBrokers/InteractiveBrokersBrokerage.cs b/Brokerages/InteractiveBrokers/InteractiveBrokersBrokerage.cs
index 91620ee9..074e5cb2 100644
--- a/Brokerages/InteractiveBrokers/InteractiveBrokersBrokerage.cs
+++ b/Brokerages/InteractiveBrokers/InteractiveBrokersBrokerage.cs
@@ -1750,7 +1750,7 @@ namespace QuantConnect.Brokerages.InteractiveBrokers
 
             order.BrokerId.Add(ibOrder.OrderId.ToString());
 
-            order.TimeInForce = ConvertTimeInForce(ibOrder.Tif);
+            order.Properties.TimeInForce = ConvertTimeInForce(ibOrder.Tif);
 
             return order;
         }
diff --git a/Brokerages/Oanda/OandaRestApiV1.cs b/Brokerages/Oanda/OandaRestApiV1.cs
index c90e8809..6d6e5f34 100644
--- a/Brokerages/Oanda/OandaRestApiV1.cs
+++ b/Brokerages/Oanda/OandaRestApiV1.cs
@@ -770,7 +770,7 @@ namespace QuantConnect.Brokerages.Oanda
                 qcOrder.Id = orderByBrokerageId.Id;
             }
 
-            qcOrder.TimeInForce = TimeInForce.Custom;
+            qcOrder.Properties.TimeInForce = TimeInForce.Custom;
             qcOrder.DurationValue = XmlConvert.ToDateTime(order.expiry, XmlDateTimeSerializationMode.Utc);
             qcOrder.Time = XmlConvert.ToDateTime(order.time, XmlDateTimeSerializationMode.Utc);
 
diff --git a/Brokerages/Oanda/OandaRestApiV20.cs b/Brokerages/Oanda/OandaRestApiV20.cs
index 3cf466a6..9590f58f 100644
--- a/Brokerages/Oanda/OandaRestApiV20.cs
+++ b/Brokerages/Oanda/OandaRestApiV20.cs
@@ -655,7 +655,7 @@ namespace QuantConnect.Brokerages.Oanda
             var gtdTime = order["gtdTime"];
             if (gtdTime != null)
             {
-                qcOrder.TimeInForce = TimeInForce.Custom;
+                qcOrder.Properties.TimeInForce = TimeInForce.Custom;
                 qcOrder.DurationValue = GetTickDateTimeFromString(gtdTime.ToString());
             }
 
diff --git a/Brokerages/Tradier/TradierBrokerage.cs b/Brokerages/Tradier/TradierBrokerage.cs
index 1a23cc22..88ac79b4 100644
--- a/Brokerages/Tradier/TradierBrokerage.cs
+++ b/Brokerages/Tradier/TradierBrokerage.cs
@@ -1513,7 +1513,7 @@ namespace QuantConnect.Brokerages.Tradier
             qcOrder.Status = ConvertStatus(order.Status);
             qcOrder.BrokerId.Add(order.Id.ToString());
             //qcOrder.ContingentId =
-            qcOrder.TimeInForce = ConvertTimeInForce(order.Duration);
+            qcOrder.Properties.TimeInForce = ConvertTimeInForce(order.Duration);
             var orderByBrokerageId = _orderProvider.GetOrderByBrokerageId(order.Id);
             if (orderByBrokerageId != null)
             {
diff --git a/Common/Interfaces/IOrderProperties.cs b/Common/Interfaces/IOrderProperties.cs
index be07b9c6..c3e85b4e 100644
--- a/Common/Interfaces/IOrderProperties.cs
+++ b/Common/Interfaces/IOrderProperties.cs
@@ -13,6 +13,8 @@
  * limitations under the License.
 */
 
+using QuantConnect.Orders;
+
 namespace QuantConnect.Interfaces
 {
     /// <summary>
@@ -20,6 +22,11 @@ namespace QuantConnect.Interfaces
     /// </summary>
     public interface IOrderProperties
     {
+        /// <summary>
+        /// Defines the length of time over which an order will continue working before it is cancelled
+        /// </summary>
+        TimeInForce TimeInForce { get; set; }
+
         /// <summary>
         /// Returns a new instance clone of this object
         /// </summary>
diff --git a/Common/Orders/GDAXOrderProperties.cs b/Common/Orders/GDAXOrderProperties.cs
index eb206e11..574bdd01 100644
--- a/Common/Orders/GDAXOrderProperties.cs
+++ b/Common/Orders/GDAXOrderProperties.cs
@@ -20,7 +20,7 @@ namespace QuantConnect.Orders
     /// <summary>
     /// Contains additional properties and settings for an order submitted to GDAX brokerage
     /// </summary>
-    public class GDAXOrderProperties : IOrderProperties
+    public class GDAXOrderProperties : OrderProperties
     {
         /// <summary>
         /// This flag will ensure the order executes only as a maker (no fee) order.
@@ -33,7 +33,7 @@ namespace QuantConnect.Orders
         /// <summary>
         /// Returns a new instance clone of this object
         /// </summary>
-        public IOrderProperties Clone()
+        public override IOrderProperties Clone()
         {
             return (GDAXOrderProperties)MemberwiseClone();
         }
diff --git a/Common/Orders/InteractiveBrokersOrderProperties.cs b/Common/Orders/InteractiveBrokersOrderProperties.cs
index b8aa463a..315521c8 100644
--- a/Common/Orders/InteractiveBrokersOrderProperties.cs
+++ b/Common/Orders/InteractiveBrokersOrderProperties.cs
@@ -20,7 +20,7 @@ namespace QuantConnect.Orders
     /// <summary>
     /// Contains additional properties and settings for an order submitted to Interactive Brokers
     /// </summary>
-    public class InteractiveBrokersOrderProperties : IOrderProperties
+    public class InteractiveBrokersOrderProperties : OrderProperties
     {
         /// <summary>
         /// The linked account for which to submit the order (only used by Financial Advisors)
@@ -51,7 +51,7 @@ namespace QuantConnect.Orders
         /// <summary>
         /// Returns a new instance clone of this object
         /// </summary>
-        public IOrderProperties Clone()
+        public override IOrderProperties Clone()
         {
             return (InteractiveBrokersOrderProperties)MemberwiseClone();
         }
diff --git a/Common/Orders/Order.cs b/Common/Orders/Order.cs
index b47d2282..4fc2a4d9 100644
--- a/Common/Orders/Order.cs
+++ b/Common/Orders/Order.cs
@@ -87,7 +87,7 @@ namespace QuantConnect.Orders
         /// <summary>
         /// Order Time In Force - GTC or Day. Day not supported in backtests.
         /// </summary>
-        public TimeInForce TimeInForce { get; internal set; }
+        public TimeInForce TimeInForce => Properties.TimeInForce;
 
         /// <summary>
         /// Tag the order with some custom data
@@ -171,11 +171,10 @@ namespace QuantConnect.Orders
             Symbol = Symbol.Empty;
             Status = OrderStatus.None;
             Tag = "";
-            TimeInForce = TimeInForce.GoodTilCancelled;
             BrokerId = new List<string>();
             ContingentId = 0;
             DurationValue = DateTime.MaxValue;
-            Properties = null;
+            Properties = new OrderProperties();
         }
 
         /// <summary>
@@ -195,11 +194,10 @@ namespace QuantConnect.Orders
             Symbol = symbol;
             Status = OrderStatus.None;
             Tag = tag;
-            TimeInForce = TimeInForce.GoodTilCancelled;
             BrokerId = new List<string>();
             ContingentId = 0;
             DurationValue = DateTime.MaxValue;
-            Properties = properties;
+            Properties = properties ?? new OrderProperties();
         }
 
         /// <summary>
@@ -270,14 +268,13 @@ namespace QuantConnect.Orders
             order.Time = Time;
             order.BrokerId = BrokerId.ToList();
             order.ContingentId = ContingentId;
-            order.TimeInForce = TimeInForce;
             order.Price = Price;
             order.PriceCurrency = PriceCurrency;
             order.Quantity = Quantity;
             order.Status = Status;
             order.Symbol = Symbol;
             order.Tag = Tag;
-            order.Properties = Properties?.Clone();
+            order.Properties = Properties.Clone();
             order.OrderSubmissionData = OrderSubmissionData?.Clone();
         }
 
diff --git a/Common/Orders/OrderJsonConverter.cs b/Common/Orders/OrderJsonConverter.cs
index 180e8e39..c249c3fa 100644
--- a/Common/Orders/OrderJsonConverter.cs
+++ b/Common/Orders/OrderJsonConverter.cs
@@ -108,7 +108,7 @@ namespace QuantConnect.Orders
             var timeInForce = jObject["TimeInForce"] ?? jObject["Duration"];
             if (timeInForce != null)
             {
-                order.TimeInForce = (TimeInForce)timeInForce.Value<int>();
+                order.Properties.TimeInForce = (TimeInForce)timeInForce.Value<int>();
             }
 
             string market = Market.USA;
diff --git a/Common/Orders/OrderProperties.cs b/Common/Orders/OrderProperties.cs
new file mode 100644
index 00000000..ce44f344
--- /dev/null
+++ b/Common/Orders/OrderProperties.cs
@@ -0,0 +1,46 @@
+﻿/*
+ * QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.
+ * Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+*/
+
+using QuantConnect.Interfaces;
+
+namespace QuantConnect.Orders
+{
+    /// <summary>
+    /// Contains additional properties and settings for an order
+    /// </summary>
+    public class OrderProperties : IOrderProperties
+    {
+        /// <summary>
+        /// Defines the length of time over which an order will continue working before it is cancelled
+        /// </summary>
+        public TimeInForce TimeInForce { get; set; }
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="OrderProperties"/> class
+        /// </summary>
+        public OrderProperties()
+        {
+            TimeInForce = TimeInForce.GoodTilCancelled;
+        }
+
+        /// <summary>
+        /// Returns a new instance clone of this object
+        /// </summary>
+        public virtual IOrderProperties Clone()
+        {
+            return (OrderProperties)MemberwiseClone();
+        }
+    }
+}
diff --git a/Common/QuantConnect.csproj b/Common/QuantConnect.csproj
index 7d0a7beb..b51716b6 100644
--- a/Common/QuantConnect.csproj
+++ b/Common/QuantConnect.csproj
@@ -193,6 +193,7 @@
     <Compile Include="Orders\GDAXOrderProperties.cs" />
     <Compile Include="Orders\InteractiveBrokersOrderProperties.cs" />
     <Compile Include="Interfaces\IOrderProperties.cs" />
+    <Compile Include="Orders\OrderProperties.cs" />
     <Compile Include="Orders\OrderSubmissionData.cs" />
     <Compile Include="Orders\TimeInForces\DayTimeInForceHandler.cs" />
     <Compile Include="Orders\TimeInForces\GoodTilCancelledTimeInForceModel.cs" />

ATOMIC:	YES


PROJECT:	Ninject
SHA:	c7ea021247e69abaa6793ec19ba1b63a2d39e94a
DIFF:
commit c7ea021247e69abaa6793ec19ba1b63a2d39e94a
Author: Joe Wasson <jwasson+git@gmail.com>
Date:   Sun Mar 27 14:25:49 2011 -0700

    Sometimes the IEnumerable<string> isn't serializable.

diff --git a/src/Ninject/Modules/CompiledModuleLoaderPlugin.cs b/src/Ninject/Modules/CompiledModuleLoaderPlugin.cs
index 0cd8b53..80cd770 100644
--- a/src/Ninject/Modules/CompiledModuleLoaderPlugin.cs
+++ b/src/Ninject/Modules/CompiledModuleLoaderPlugin.cs
@@ -69,7 +69,7 @@ namespace Ninject.Modules
                 var checker = (ModuleChecker)temporaryDomain.CreateInstanceAndUnwrap(
                     moduleCheckerType.Assembly.FullName, moduleCheckerType.FullName ?? String.Empty);
 
-                return checker.CheckModules(filenames);
+                return checker.CheckModules(filenames.ToArray());
             }
             finally
             {

ATOMIC:	YES
